{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function (config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n    var last;\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" && (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n    function tokenTop(stream, state) {\n      var string = stream.string;\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    }\n\n    // parsing Smarty content\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n        return cont(\"tag\", null);\n      }\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n      var ch = stream.next();\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        }\n        if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n        var str = \"\";\n        if (ch != \"/\") {\n          str += ch;\n        }\n        var c = null;\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n        for (var i = 0, j = keyFunctions.length; i < j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n        return cont(\"tag\", \"tag\");\n      }\n    }\n    function tokenAttribute(quote) {\n      return function (stream, state) {\n        var prevChar = null;\n        var currChar = null;\n        while (!stream.eol()) {\n          currChar = stream.peek();\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n          prevChar = currChar;\n        }\n        return \"string\";\n      };\n    }\n    function tokenBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n    return {\n      startState: function () {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function (state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function (state) {\n        if (state.tokenize == tokenTop) return {\n          mode: baseMode,\n          state: state.base\n        };\n      },\n      token: function (stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function (state, text, line) {\n        if (state.tokenize == tokenTop && baseMode.indent) return baseMode.indent(state.base, text, line);else return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConf","rightDelimiter","leftDelimiter","version","baseMode","getMode","keyFunctions","regs","operatorChars","validIdentifier","stringChar","last","cont","style","lastType","chain","stream","state","parser","tokenize","doesNotCount","pos","string","length","test","charAt","tokenTop","scan","nextMatch","indexOf","match","eat","tokenBlock","depth","tokenSmarty","slice","token","base","ch","next","eatWhile","tokenAttribute","str","c","i","j","quote","prevChar","currChar","eol","peek","terminator","startState","copyState","innerMode","mode","indent","text","line","Pass","blockCommentStart","blockCommentEnd","defineMIME"],"sources":["C:/Users/User/Downloads/Multisender-App-main/node_modules/codemirror/mode/smarty/smarty.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function(config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n\n    var last;\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" &&\n        (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    }\n\n    // parsing Smarty content\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        } if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n        if (ch != \"/\") {\n          str += ch;\n        }\n        var c = null;\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n        for (var i=0, j=keyFunctions.length; i<j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function(stream, state) {\n        var prevChar = null;\n        var currChar = null;\n        while (!stream.eol()) {\n          currChar = stream.peek();\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n          prevChar = currChar;\n        }\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n\n    return {\n      startState: function() {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function(state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function(state) {\n        if (state.tokenize == tokenTop)\n          return {mode: baseMode, state: state.base};\n      },\n      token: function(stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function(state, text, line) {\n        if (state.tokenize == tokenTop && baseMode.indent)\n          return baseMode.indent(state.base, text, line);\n        else\n          return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});\n"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,UAASA,GAAG,EAAE;EACb,IAAI,OAAOC,OAAO,IAAI,QAAQ,IAAI,OAAOC,MAAM,IAAI,QAAQ;IAAE;IAC3DF,GAAG,CAACG,OAAO,CAAC,sBAAsB,CAAC,CAAC,CAAC,KAClC,IAAI,OAAOC,MAAM,IAAI,UAAU,IAAIA,MAAM,CAACC,GAAG;IAAE;IAClDD,MAAM,CAAC,CAAC,sBAAsB,CAAC,EAAEJ,GAAG,CAAC,CAAC;IACnC;IACHA,GAAG,CAACM,UAAU,CAAC;AACnB,CAAC,EAAE,UAASA,UAAU,EAAE;EACtB,YAAY;;EAEZA,UAAU,CAACC,UAAU,CAAC,QAAQ,EAAE,UAASC,MAAM,EAAEC,UAAU,EAAE;IAC3D,IAAIC,cAAc,GAAGD,UAAU,CAACC,cAAc,IAAI,GAAG;IACrD,IAAIC,aAAa,GAAGF,UAAU,CAACE,aAAa,IAAI,GAAG;IACnD,IAAIC,OAAO,GAAGH,UAAU,CAACG,OAAO,IAAI,CAAC;IACrC,IAAIC,QAAQ,GAAGP,UAAU,CAACQ,OAAO,CAACN,MAAM,EAAEC,UAAU,CAACI,QAAQ,IAAI,MAAM,CAAC;IAExE,IAAIE,YAAY,GAAG,CAAC,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,SAAS,CAAC;IACzE,IAAIC,IAAI,GAAG;MACTC,aAAa,EAAE,eAAe;MAC9BC,eAAe,EAAE,cAAc;MAC/BC,UAAU,EAAE;IACd,CAAC;IAED,IAAIC,IAAI;IACR,SAASC,IAAIA,CAACC,KAAK,EAAEC,QAAQ,EAAE;MAC7BH,IAAI,GAAGG,QAAQ;MACf,OAAOD,KAAK;IACd;IAEA,SAASE,KAAKA,CAACC,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAE;MACpCD,KAAK,CAACE,QAAQ,GAAGD,MAAM;MACvB,OAAOA,MAAM,CAACF,MAAM,EAAEC,KAAK,CAAC;IAC9B;;IAEA;IACA,SAASG,YAAYA,CAACJ,MAAM,EAAEK,GAAG,EAAE;MACjC,IAAIA,GAAG,IAAI,IAAI,EAAEA,GAAG,GAAGL,MAAM,CAACK,GAAG;MACjC,OAAOlB,OAAO,KAAK,CAAC,IAAID,aAAa,IAAI,GAAG,KACzCmB,GAAG,IAAIL,MAAM,CAACM,MAAM,CAACC,MAAM,IAAI,IAAI,CAACC,IAAI,CAACR,MAAM,CAACM,MAAM,CAACG,MAAM,CAACJ,GAAG,CAAC,CAAC,CAAC;IACzE;IAEA,SAASK,QAAQA,CAACV,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAIK,MAAM,GAAGN,MAAM,CAACM,MAAM;MAC1B,KAAK,IAAIK,IAAI,GAAGX,MAAM,CAACK,GAAG,IAAI;QAC5B,IAAIO,SAAS,GAAGN,MAAM,CAACO,OAAO,CAAC3B,aAAa,EAAEyB,IAAI,CAAC;QACnDA,IAAI,GAAGC,SAAS,GAAG1B,aAAa,CAACqB,MAAM;QACvC,IAAIK,SAAS,IAAI,CAAC,CAAC,IAAI,CAACR,YAAY,CAACJ,MAAM,EAAEY,SAAS,GAAG1B,aAAa,CAACqB,MAAM,CAAC,EAAE;MAClF;MACA,IAAIK,SAAS,IAAIZ,MAAM,CAACK,GAAG,EAAE;QAC3BL,MAAM,CAACc,KAAK,CAAC5B,aAAa,CAAC;QAC3B,IAAIc,MAAM,CAACe,GAAG,CAAC,GAAG,CAAC,EAAE;UACnB,OAAOhB,KAAK,CAACC,MAAM,EAAEC,KAAK,EAAEe,UAAU,CAAC,SAAS,EAAE,GAAG,GAAG/B,cAAc,CAAC,CAAC;QAC1E,CAAC,MAAM;UACLgB,KAAK,CAACgB,KAAK,EAAE;UACbhB,KAAK,CAACE,QAAQ,GAAGe,WAAW;UAC5BvB,IAAI,GAAG,UAAU;UACjB,OAAO,KAAK;QACd;MACF;MAEA,IAAIiB,SAAS,GAAG,CAAC,CAAC,EAAEZ,MAAM,CAACM,MAAM,GAAGA,MAAM,CAACa,KAAK,CAAC,CAAC,EAAEP,SAAS,CAAC;MAC9D,IAAIQ,KAAK,GAAGhC,QAAQ,CAACgC,KAAK,CAACpB,MAAM,EAAEC,KAAK,CAACoB,IAAI,CAAC;MAC9C,IAAIT,SAAS,GAAG,CAAC,CAAC,EAAEZ,MAAM,CAACM,MAAM,GAAGA,MAAM;MAC1C,OAAOc,KAAK;IACd;;IAEA;IACA,SAASF,WAAWA,CAAClB,MAAM,EAAEC,KAAK,EAAE;MAClC,IAAID,MAAM,CAACc,KAAK,CAAC7B,cAAc,EAAE,IAAI,CAAC,EAAE;QACtC,IAAIE,OAAO,KAAK,CAAC,EAAE;UACjBc,KAAK,CAACgB,KAAK,EAAE;UACb,IAAIhB,KAAK,CAACgB,KAAK,IAAI,CAAC,EAAE;YACpBhB,KAAK,CAACE,QAAQ,GAAGO,QAAQ;UAC3B;QACF,CAAC,MAAM;UACLT,KAAK,CAACE,QAAQ,GAAGO,QAAQ;QAC3B;QACA,OAAOd,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC;MAC1B;MAEA,IAAII,MAAM,CAACc,KAAK,CAAC5B,aAAa,EAAE,IAAI,CAAC,EAAE;QACrCe,KAAK,CAACgB,KAAK,EAAE;QACb,OAAOrB,IAAI,CAAC,KAAK,EAAE,UAAU,CAAC;MAChC;MAEA,IAAI0B,EAAE,GAAGtB,MAAM,CAACuB,IAAI,CAAC,CAAC;MACtB,IAAID,EAAE,IAAI,GAAG,EAAE;QACbtB,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACE,eAAe,CAAC;QACrC,OAAOG,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC;MACvC,CAAC,MAAM,IAAI0B,EAAE,IAAI,GAAG,EAAE;QACpB,OAAO1B,IAAI,CAAC,UAAU,EAAE,MAAM,CAAC;MACjC,CAAC,MAAM,IAAI0B,EAAE,IAAI,GAAG,EAAE;QACpB,OAAO1B,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC;MACrC,CAAC,MAAM,IAAIL,IAAI,CAACG,UAAU,CAACc,IAAI,CAACc,EAAE,CAAC,EAAE;QACnCrB,KAAK,CAACE,QAAQ,GAAGsB,cAAc,CAACH,EAAE,CAAC;QACnC,OAAO1B,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC;MACjC,CAAC,MAAM,IAAIL,IAAI,CAACC,aAAa,CAACgB,IAAI,CAACc,EAAE,CAAC,EAAE;QACtCtB,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACC,aAAa,CAAC;QACnC,OAAOI,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC;MACrC,CAAC,MAAM,IAAI0B,EAAE,IAAI,GAAG,IAAIA,EAAE,IAAI,GAAG,EAAE;QACjC,OAAO1B,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC;MACnC,CAAC,MAAM,IAAI0B,EAAE,IAAI,GAAG,IAAIA,EAAE,IAAI,GAAG,EAAE;QACjC,OAAO1B,IAAI,CAAC,SAAS,EAAE,UAAU,CAAC;MACpC,CAAC,MAAM,IAAI,IAAI,CAACY,IAAI,CAACc,EAAE,CAAC,EAAE;QACxBtB,MAAM,CAACwB,QAAQ,CAAC,IAAI,CAAC;QACrB,OAAO5B,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC;MACjC,CAAC,MAAM;QAEL,IAAIK,KAAK,CAACN,IAAI,IAAI,UAAU,EAAE;UAC5B,IAAI2B,EAAE,IAAI,GAAG,EAAE;YACbtB,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACE,eAAe,CAAC;YACrC,OAAOG,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC;UACrC,CAAC,MAAM,IAAI0B,EAAE,IAAI,GAAG,EAAE;YACpBtB,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACE,eAAe,CAAC;YACrC,OAAOG,IAAI,CAAC,WAAW,EAAE,UAAU,CAAC;UACtC;QACF,CAAC,MAAM,IAAIK,KAAK,CAACN,IAAI,IAAI,MAAM,EAAE;UAC/BK,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACE,eAAe,CAAC;UACrC,OAAOG,IAAI,CAAC,WAAW,EAAE,UAAU,CAAC;QACtC,CAAC,MAAM,IAAIK,KAAK,CAACN,IAAI,IAAI,YAAY,EAAE;UACrCK,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACE,eAAe,CAAC;UACrC,OAAOG,IAAI,CAAC,WAAW,EAAE,UAAU,CAAC;QACtC;QAAE,IAAIK,KAAK,CAACN,IAAI,IAAI,UAAU,EAAE;UAC9BK,MAAM,CAACwB,QAAQ,CAACjC,IAAI,CAACE,eAAe,CAAC;UACrC,OAAOG,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC;QAC/B,CAAC,MAAM,IAAI,IAAI,CAACY,IAAI,CAACc,EAAE,CAAC,EAAE;UACxB3B,IAAI,GAAG,YAAY;UACnB,OAAO,IAAI;QACb;QAEA,IAAI+B,GAAG,GAAG,EAAE;QACZ,IAAIJ,EAAE,IAAI,GAAG,EAAE;UACbI,GAAG,IAAIJ,EAAE;QACX;QACA,IAAIK,CAAC,GAAG,IAAI;QACZ,OAAOA,CAAC,GAAG3B,MAAM,CAACe,GAAG,CAACxB,IAAI,CAACE,eAAe,CAAC,EAAE;UAC3CiC,GAAG,IAAIC,CAAC;QACV;QACA,KAAK,IAAIC,CAAC,GAAC,CAAC,EAAEC,CAAC,GAACvC,YAAY,CAACiB,MAAM,EAAEqB,CAAC,GAACC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAItC,YAAY,CAACsC,CAAC,CAAC,IAAIF,GAAG,EAAE;YAC1B,OAAO9B,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC;UACnC;QACF;QACA,IAAI,IAAI,CAACY,IAAI,CAACc,EAAE,CAAC,EAAE;UACjB,OAAO,IAAI;QACb;QACA,OAAO1B,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC;MAC3B;IACF;IAEA,SAAS6B,cAAcA,CAACK,KAAK,EAAE;MAC7B,OAAO,UAAS9B,MAAM,EAAEC,KAAK,EAAE;QAC7B,IAAI8B,QAAQ,GAAG,IAAI;QACnB,IAAIC,QAAQ,GAAG,IAAI;QACnB,OAAO,CAAChC,MAAM,CAACiC,GAAG,CAAC,CAAC,EAAE;UACpBD,QAAQ,GAAGhC,MAAM,CAACkC,IAAI,CAAC,CAAC;UACxB,IAAIlC,MAAM,CAACuB,IAAI,CAAC,CAAC,IAAIO,KAAK,IAAIC,QAAQ,KAAK,IAAI,EAAE;YAC/C9B,KAAK,CAACE,QAAQ,GAAGe,WAAW;YAC5B;UACF;UACAa,QAAQ,GAAGC,QAAQ;QACrB;QACA,OAAO,QAAQ;MACjB,CAAC;IACH;IAEA,SAAShB,UAAUA,CAACnB,KAAK,EAAEsC,UAAU,EAAE;MACrC,OAAO,UAASnC,MAAM,EAAEC,KAAK,EAAE;QAC7B,OAAO,CAACD,MAAM,CAACiC,GAAG,CAAC,CAAC,EAAE;UACpB,IAAIjC,MAAM,CAACc,KAAK,CAACqB,UAAU,CAAC,EAAE;YAC5BlC,KAAK,CAACE,QAAQ,GAAGO,QAAQ;YACzB;UACF;UACAV,MAAM,CAACuB,IAAI,CAAC,CAAC;QACf;QACA,OAAO1B,KAAK;MACd,CAAC;IACH;IAEA,OAAO;MACLuC,UAAU,EAAE,SAAAA,CAAA,EAAW;QACrB,OAAO;UACLf,IAAI,EAAExC,UAAU,CAACuD,UAAU,CAAChD,QAAQ,CAAC;UACrCe,QAAQ,EAAEO,QAAQ;UAClBf,IAAI,EAAE,IAAI;UACVsB,KAAK,EAAE;QACT,CAAC;MACH,CAAC;MACDoB,SAAS,EAAE,SAAAA,CAASpC,KAAK,EAAE;QACzB,OAAO;UACLoB,IAAI,EAAExC,UAAU,CAACwD,SAAS,CAACjD,QAAQ,EAAEa,KAAK,CAACoB,IAAI,CAAC;UAChDlB,QAAQ,EAAEF,KAAK,CAACE,QAAQ;UACxBR,IAAI,EAAEM,KAAK,CAACN,IAAI;UAChBsB,KAAK,EAAEhB,KAAK,CAACgB;QACf,CAAC;MACH,CAAC;MACDqB,SAAS,EAAE,SAAAA,CAASrC,KAAK,EAAE;QACzB,IAAIA,KAAK,CAACE,QAAQ,IAAIO,QAAQ,EAC5B,OAAO;UAAC6B,IAAI,EAAEnD,QAAQ;UAAEa,KAAK,EAAEA,KAAK,CAACoB;QAAI,CAAC;MAC9C,CAAC;MACDD,KAAK,EAAE,SAAAA,CAASpB,MAAM,EAAEC,KAAK,EAAE;QAC7B,IAAIJ,KAAK,GAAGI,KAAK,CAACE,QAAQ,CAACH,MAAM,EAAEC,KAAK,CAAC;QACzCA,KAAK,CAACN,IAAI,GAAGA,IAAI;QACjB,OAAOE,KAAK;MACd,CAAC;MACD2C,MAAM,EAAE,SAAAA,CAASvC,KAAK,EAAEwC,IAAI,EAAEC,IAAI,EAAE;QAClC,IAAIzC,KAAK,CAACE,QAAQ,IAAIO,QAAQ,IAAItB,QAAQ,CAACoD,MAAM,EAC/C,OAAOpD,QAAQ,CAACoD,MAAM,CAACvC,KAAK,CAACoB,IAAI,EAAEoB,IAAI,EAAEC,IAAI,CAAC,CAAC,KAE/C,OAAO7D,UAAU,CAAC8D,IAAI;MAC1B,CAAC;MACDC,iBAAiB,EAAE1D,aAAa,GAAG,GAAG;MACtC2D,eAAe,EAAE,GAAG,GAAG5D;IACzB,CAAC;EACH,CAAC,CAAC;EAEFJ,UAAU,CAACiE,UAAU,CAAC,eAAe,EAAE,QAAQ,CAAC;AAClD,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}