{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var rfc2822 = [\"From\", \"Sender\", \"Reply-To\", \"To\", \"Cc\", \"Bcc\", \"Message-ID\", \"In-Reply-To\", \"References\", \"Resent-From\", \"Resent-Sender\", \"Resent-To\", \"Resent-Cc\", \"Resent-Bcc\", \"Resent-Message-ID\", \"Return-Path\", \"Received\"];\n  var rfc2822NoEmail = [\"Date\", \"Subject\", \"Comments\", \"Keywords\", \"Resent-Date\"];\n  CodeMirror.registerHelper(\"hintWords\", \"mbox\", rfc2822.concat(rfc2822NoEmail));\n  var whitespace = /^[ \\t]/;\n  var separator = /^From /; // See RFC 4155\n  var rfc2822Header = new RegExp(\"^(\" + rfc2822.join(\"|\") + \"): \");\n  var rfc2822HeaderNoEmail = new RegExp(\"^(\" + rfc2822NoEmail.join(\"|\") + \"): \");\n  var header = /^[^:]+:/; // Optional fields defined in RFC 2822\n  var email = /^[^ ]+@[^ ]+/;\n  var untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;\n  var bracketedEmail = /^<.*?>/;\n  var untilBracketedEmail = /^.*?(?=<.*>)/;\n  function styleForHeader(header) {\n    if (header === \"Subject\") return \"header\";\n    return \"string\";\n  }\n  function readToken(stream, state) {\n    if (stream.sol()) {\n      // From last line\n      state.inSeparator = false;\n      if (state.inHeader && stream.match(whitespace)) {\n        // Header folding\n        return null;\n      } else {\n        state.inHeader = false;\n        state.header = null;\n      }\n      if (stream.match(separator)) {\n        state.inHeaders = true;\n        state.inSeparator = true;\n        return \"atom\";\n      }\n      var match;\n      var emailPermitted = false;\n      if ((match = stream.match(rfc2822HeaderNoEmail)) || (emailPermitted = true) && (match = stream.match(rfc2822Header))) {\n        state.inHeaders = true;\n        state.inHeader = true;\n        state.emailPermitted = emailPermitted;\n        state.header = match[1];\n        return \"atom\";\n      }\n\n      // Use vim's heuristics: recognize custom headers only if the line is in a\n      // block of legitimate headers.\n      if (state.inHeaders && (match = stream.match(header))) {\n        state.inHeader = true;\n        state.emailPermitted = true;\n        state.header = match[1];\n        return \"atom\";\n      }\n      state.inHeaders = false;\n      stream.skipToEnd();\n      return null;\n    }\n    if (state.inSeparator) {\n      if (stream.match(email)) return \"link\";\n      if (stream.match(untilEmail)) return \"atom\";\n      stream.skipToEnd();\n      return \"atom\";\n    }\n    if (state.inHeader) {\n      var style = styleForHeader(state.header);\n      if (state.emailPermitted) {\n        if (stream.match(bracketedEmail)) return style + \" link\";\n        if (stream.match(untilBracketedEmail)) return style;\n      }\n      stream.skipToEnd();\n      return style;\n    }\n    stream.skipToEnd();\n    return null;\n  }\n  ;\n  CodeMirror.defineMode(\"mbox\", function () {\n    return {\n      startState: function () {\n        return {\n          // Is in a mbox separator\n          inSeparator: false,\n          // Is in a mail header\n          inHeader: false,\n          // If bracketed email is permitted. Only applicable when inHeader\n          emailPermitted: false,\n          // Name of current header\n          header: null,\n          // Is in a region of mail headers\n          inHeaders: false\n        };\n      },\n      token: readToken,\n      blankLine: function (state) {\n        state.inHeaders = state.inSeparator = state.inHeader = false;\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"application/mbox\", \"mbox\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","rfc2822","rfc2822NoEmail","registerHelper","concat","whitespace","separator","rfc2822Header","RegExp","join","rfc2822HeaderNoEmail","header","email","untilEmail","bracketedEmail","untilBracketedEmail","styleForHeader","readToken","stream","state","sol","inSeparator","inHeader","match","inHeaders","emailPermitted","skipToEnd","style","defineMode","startState","token","blankLine","defineMIME"],"sources":["C:/Users/User/Downloads/Salary Payments/node_modules/codemirror/mode/mbox/mbox.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar rfc2822 = [\n  \"From\", \"Sender\", \"Reply-To\", \"To\", \"Cc\", \"Bcc\", \"Message-ID\",\n  \"In-Reply-To\", \"References\", \"Resent-From\", \"Resent-Sender\", \"Resent-To\",\n  \"Resent-Cc\", \"Resent-Bcc\", \"Resent-Message-ID\", \"Return-Path\", \"Received\"\n];\nvar rfc2822NoEmail = [\n  \"Date\", \"Subject\", \"Comments\", \"Keywords\", \"Resent-Date\"\n];\n\nCodeMirror.registerHelper(\"hintWords\", \"mbox\", rfc2822.concat(rfc2822NoEmail));\n\nvar whitespace = /^[ \\t]/;\nvar separator = /^From /; // See RFC 4155\nvar rfc2822Header = new RegExp(\"^(\" + rfc2822.join(\"|\") + \"): \");\nvar rfc2822HeaderNoEmail = new RegExp(\"^(\" + rfc2822NoEmail.join(\"|\") + \"): \");\nvar header = /^[^:]+:/; // Optional fields defined in RFC 2822\nvar email = /^[^ ]+@[^ ]+/;\nvar untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;\nvar bracketedEmail = /^<.*?>/;\nvar untilBracketedEmail = /^.*?(?=<.*>)/;\n\nfunction styleForHeader(header) {\n  if (header === \"Subject\") return \"header\";\n  return \"string\";\n}\n\nfunction readToken(stream, state) {\n  if (stream.sol()) {\n    // From last line\n    state.inSeparator = false;\n    if (state.inHeader && stream.match(whitespace)) {\n      // Header folding\n      return null;\n    } else {\n      state.inHeader = false;\n      state.header = null;\n    }\n\n    if (stream.match(separator)) {\n      state.inHeaders = true;\n      state.inSeparator = true;\n      return \"atom\";\n    }\n\n    var match;\n    var emailPermitted = false;\n    if ((match = stream.match(rfc2822HeaderNoEmail)) ||\n        (emailPermitted = true) && (match = stream.match(rfc2822Header))) {\n      state.inHeaders = true;\n      state.inHeader = true;\n      state.emailPermitted = emailPermitted;\n      state.header = match[1];\n      return \"atom\";\n    }\n\n    // Use vim's heuristics: recognize custom headers only if the line is in a\n    // block of legitimate headers.\n    if (state.inHeaders && (match = stream.match(header))) {\n      state.inHeader = true;\n      state.emailPermitted = true;\n      state.header = match[1];\n      return \"atom\";\n    }\n\n    state.inHeaders = false;\n    stream.skipToEnd();\n    return null;\n  }\n\n  if (state.inSeparator) {\n    if (stream.match(email)) return \"link\";\n    if (stream.match(untilEmail)) return \"atom\";\n    stream.skipToEnd();\n    return \"atom\";\n  }\n\n  if (state.inHeader) {\n    var style = styleForHeader(state.header);\n\n    if (state.emailPermitted) {\n      if (stream.match(bracketedEmail)) return style + \" link\";\n      if (stream.match(untilBracketedEmail)) return style;\n    }\n    stream.skipToEnd();\n    return style;\n  }\n\n  stream.skipToEnd();\n  return null;\n};\n\nCodeMirror.defineMode(\"mbox\", function() {\n  return {\n    startState: function() {\n      return {\n        // Is in a mbox separator\n        inSeparator: false,\n        // Is in a mail header\n        inHeader: false,\n        // If bracketed email is permitted. Only applicable when inHeader\n        emailPermitted: false,\n        // Name of current header\n        header: null,\n        // Is in a region of mail headers\n        inHeaders: false\n      };\n    },\n    token: readToken,\n    blankLine: function(state) {\n      state.inHeaders = state.inSeparator = state.inHeader = false;\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"application/mbox\", \"mbox\");\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}