{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"verilog\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n      // indentation follows the same rules as everything else. Otherwise if\n      // false, compiler directives will track their own indentation.\n      // For example, `ifdef nested inside another `ifndef will be indented,\n      // but a `ifdef inside a function block may not be indented.\n      compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n    function words(str) {\n      var obj = {},\n        words = str.split(\" \");\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n      return obj;\n    }\n\n    /**\n     * Keywords from IEEE 1800-2012\n     */\n    var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" + \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" + \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" + \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" + \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" + \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" + \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" + \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" + \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" + \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" + \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" + \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" + \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" + \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" + \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" + \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" + \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" + \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n    /** Operators from IEEE 1800-2012\n       unary_operator ::=\n         + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_operator ::=\n         + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n         | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n         | -> | <->\n       inc_or_dec_operator ::= ++ | --\n       unary_module_path_operator ::=\n         ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_module_path_operator ::=\n         == | != | && | || | & | | | ^ | ^~ | ~^\n    */\n    var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n    var isBracketChar = /[\\[\\]{}()]/;\n    var unsignedNumber = /\\d[0-9_]*/;\n    var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n    var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n    var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n    var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n    var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n    var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n    var closingBracket = /[)}\\]]/;\n    var compilerDirectiveRegex = new RegExp(\"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" + \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n    var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n    var compilerDirectiveEndRegex = /^(`(?:elsif|else|endif))\\b/;\n    var curPunc;\n    var curKeyword;\n\n    // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n    // E.g. \"task\" => \"endtask\"\n    var blockKeywords = words(\"case checker class clocking config function generate interface module package \" + \"primitive program property specify sequence table task\");\n\n    // Opening/closing pairs\n    var openClose = {};\n    for (var keyword in blockKeywords) {\n      openClose[keyword] = \"end\" + keyword;\n    }\n    openClose[\"begin\"] = \"end\";\n    openClose[\"casex\"] = \"endcase\";\n    openClose[\"casez\"] = \"endcase\";\n    openClose[\"do\"] = \"while\";\n    openClose[\"fork\"] = \"join;join_any;join_none\";\n    openClose[\"covergroup\"] = \"endgroup\";\n    openClose[\"macro_begin\"] = \"macro_end\";\n    for (var i in noIndentKeywords) {\n      var keyword = noIndentKeywords[i];\n      if (openClose[keyword]) {\n        openClose[keyword] = undefined;\n      }\n    }\n\n    // Keywords which open statements that are ended with a semi-colon\n    var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n    function tokenBase(stream, state) {\n      var ch = stream.peek(),\n        style;\n      if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n      if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n      if (/[,;:\\.]/.test(ch)) {\n        curPunc = stream.next();\n        return null;\n      }\n      if (isBracketChar.test(ch)) {\n        curPunc = stream.next();\n        return \"bracket\";\n      }\n      // Macros (tick-defines)\n      if (ch == '`') {\n        stream.next();\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          var cur = stream.current();\n          curKeyword = cur;\n          // Macros that end in _begin, are start of block and end with _end\n          if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n            var keywordClose = curKeyword.substr(0, curKeyword.length - 5) + \"end\";\n            openClose[cur] = keywordClose;\n            curPunc = \"newblock\";\n          } else {\n            stream.eatSpace();\n            if (stream.peek() == '(') {\n              // Check if this is a block\n              curPunc = \"newmacro\";\n            }\n            var withSpace = stream.current();\n            // Move the stream back before the spaces\n            stream.backUp(withSpace.length - cur.length);\n          }\n          return \"def\";\n        } else {\n          return null;\n        }\n      }\n      // System calls\n      if (ch == '$') {\n        stream.next();\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          return \"meta\";\n        } else {\n          return null;\n        }\n      }\n      // Time literals\n      if (ch == '#') {\n        stream.next();\n        stream.eatWhile(/[\\d_.]/);\n        return \"def\";\n      }\n      // Event\n      if (ch == '@') {\n        stream.next();\n        stream.eatWhile(/[@]/);\n        return \"def\";\n      }\n      // Strings\n      if (ch == '\"') {\n        stream.next();\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n      // Comments\n      if (ch == \"/\") {\n        stream.next();\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n        stream.backUp(1);\n      }\n\n      // Numeric literals\n      if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) {\n        return \"number\";\n      }\n\n      // Operators\n      if (stream.eatWhile(isOperatorChar)) {\n        curPunc = stream.current();\n        return \"meta\";\n      }\n\n      // Keywords / plain variables\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n        if (keywords[cur]) {\n          if (openClose[cur]) {\n            curPunc = \"newblock\";\n            if (cur === \"fork\") {\n              // Fork can be a statement instead of block in cases of:\n              // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n              stream.eatSpace();\n              if (stream.peek() == ';') {\n                curPunc = \"newstatement\";\n              }\n              stream.backUp(stream.current().length - cur.length);\n            }\n          }\n          if (statementKeywords[cur]) {\n            curPunc = \"newstatement\";\n          }\n          curKeyword = cur;\n          return \"keyword\";\n        }\n        return \"variable\";\n      }\n      stream.next();\n      return null;\n    }\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n          next,\n          end = false;\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n        if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n        ch;\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        maybeEnd = ch == \"*\";\n      }\n      return \"comment\";\n    }\n    function Context(indented, column, type, scopekind, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.scopekind = scopekind;\n      this.align = align;\n      this.prev = prev;\n    }\n    function pushContext(state, col, type, scopekind) {\n      var indent = state.indented;\n      var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n      return state.context = c;\n    }\n    function popContext(state) {\n      var t = state.context.type;\n      if (t == \")\" || t == \"]\" || t == \"}\") {\n        state.indented = state.context.indented;\n      }\n      return state.context = state.context.prev;\n    }\n    function isClosing(text, contextClosing) {\n      if (text == contextClosing) {\n        return true;\n      } else {\n        // contextClosing may be multiple keywords separated by ;\n        var closingKeywords = contextClosing.split(\";\");\n        for (var i in closingKeywords) {\n          if (text == closingKeywords[i]) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n    function isInsideScopeKind(ctx, scopekind) {\n      if (ctx == null) {\n        return false;\n      }\n      if (ctx.scopekind === scopekind) {\n        return true;\n      }\n      return isInsideScopeKind(ctx.prev, scopekind);\n    }\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on any bracket char: {}()[]\n      // or on a match of any of the block closing keywords, at\n      // the end of a line\n      var allClosings = [];\n      for (var i in openClose) {\n        if (openClose[i]) {\n          var closings = openClose[i].split(\";\");\n          for (var j in closings) {\n            allClosings.push(closings[j]);\n          }\n        }\n      }\n      var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n      return re;\n    }\n\n    // Interface\n    return {\n      // Regex to force current line to reindent\n      electricInput: buildElectricInputRegEx(),\n      startState: function (basecolumn) {\n        var state = {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n          indented: 0,\n          compilerDirectiveIndented: 0,\n          startOfLine: true\n        };\n        if (hooks.startState) hooks.startState(state);\n        return state;\n      },\n      token: function (stream, state) {\n        var ctx = state.context;\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n        if (hooks.token) {\n          // Call hook, with an optional return value of a style to override verilog styling.\n          var style = hooks.token(stream, state);\n          if (style !== undefined) {\n            return style;\n          }\n        }\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        curKeyword = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n          if ((curPunc === \"=\" || curPunc === \"<=\") && !isInsideScopeKind(ctx, \"assignment\")) {\n            // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n            //      Search through the context to see if we are already in an assignment.\n            // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n            pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n            if (ctx.align == null) ctx.align = true;\n          }\n          return style;\n        }\n        if (ctx.align == null) ctx.align = true;\n        var isClosingAssignment = ctx.type == \"assignment\" && closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n        if (curPunc == ctx.type || isClosingAssignment) {\n          if (isClosingAssignment) {\n            ctx = popContext(state);\n          }\n          ctx = popContext(state);\n          if (curPunc == \")\") {\n            // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n            if (ctx && ctx.type === \"macro\") {\n              ctx = popContext(state);\n              while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n            }\n          } else if (curPunc == \"}\") {\n            // Handle closing statements like constraint block: \"foreach () {}\" which\n            // do not have semicolon at end.\n            if (ctx && ctx.type === \"statement\") {\n              while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n            }\n          }\n        } else if ((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\") || ctx.type && isClosing(curKeyword, ctx.type)) {\n          ctx = popContext(state);\n          while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n        } else if (curPunc == \"{\") {\n          pushContext(state, stream.column(), \"}\");\n        } else if (curPunc == \"[\") {\n          pushContext(state, stream.column(), \"]\");\n        } else if (curPunc == \"(\") {\n          pushContext(state, stream.column(), \")\");\n        } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n          pushContext(state, stream.column(), \"statement\", \"case\");\n        } else if (curPunc == \"newstatement\") {\n          pushContext(state, stream.column(), \"statement\", curKeyword);\n        } else if (curPunc == \"newblock\") {\n          if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n            // The 'function' keyword can appear in some other contexts where it actually does not\n            // indicate a function (import/export DPI and covergroup definitions).\n            // Do nothing in this case\n          } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n            // Same thing for task\n          } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {\n            // Same thing for class (e.g. typedef)\n          } else {\n            var close = openClose[curKeyword];\n            pushContext(state, stream.column(), close, curKeyword);\n          }\n        } else if (curPunc == \"newmacro\" || curKeyword && curKeyword.match(compilerDirectiveRegex)) {\n          if (curPunc == \"newmacro\") {\n            // Macros (especially if they have parenthesis) potentially have a semicolon\n            // or complete statement/block inside, and should be treated as such.\n            pushContext(state, stream.column(), \"macro\", \"macro\");\n          }\n          if (curKeyword.match(compilerDirectiveEndRegex)) {\n            state.compilerDirectiveIndented -= statementIndentUnit;\n          }\n          if (curKeyword.match(compilerDirectiveBeginRegex)) {\n            state.compilerDirectiveIndented += statementIndentUnit;\n          }\n        }\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function (state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n        if (hooks.indent) {\n          var fromHook = hooks.indent(state);\n          if (fromHook >= 0) return fromHook;\n        }\n        var ctx = state.context,\n          firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        var closing = false;\n        var possibleClosing = textAfter.match(closingBracketOrWord);\n        if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n        if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n          if (textAfter.match(compilerDirectiveEndRegex)) {\n            return state.compilerDirectiveIndented - statementIndentUnit;\n          }\n          return state.compilerDirectiveIndented;\n        }\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\") && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n      fold: \"indent\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  });\n\n  // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",\n    // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",\n    // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  };\n\n  // Lines starting with these characters define scope (result in indentation).\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/;\n\n  // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit; // TODO: Pass this in instead.\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  }\n\n  // Return true if the next thing in the stream is an identifier with a mnemonic.\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n    hooks: {\n      electricInput: false,\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function (stream, state) {\n        var style = undefined;\n        var match; // Return value of pattern matches.\n\n        // Set highlighting mode based on code region (TLV or SV).\n        if (stream.sol() && !state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)) {\n              state.tlvCodeActive = true;\n            }\n          }\n          // Correct indentation in the face of a line prefix char.\n          if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          }\n\n          // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n              if (tlvScopePrefixChars[ch] && (match = bodyString.match(tlvIdentMatch)) && tlvIdentifierStyle[match[1]]) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit;\n                // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                  if (tlvTrackStatements) {\n                    state.statementComment = false;\n                  }\n                  depth++;\n                }\n              }\n            }\n            // Clear out deeper indentation levels unless line is blank.\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          }\n          // Set next level of indentation.\n          state.tlvNextIndent = indented;\n        }\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n\n          var beginStatement = false;\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement = stream.peek() != \" \" &&\n            // not a space\n            style === undefined &&\n            // not a region identifier\n            !state.tlvInBlockComment &&\n            // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n            stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit; // at scope level\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n              state.statementComment = stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n          var match;\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\");\n          } else if (stream.pos / tlvIndentUnit < state.tlvIndentationStyle.length && (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style =\n            // make this style distinct from the previous one to prevent\n            // codemirror from combining spans\n            \"tlv-indent-\" + (stream.pos % 2 == 0 ? \"even\" : \"odd\") +\n            // and style it\n            \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\");\n            // Style the line prefix character.\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            }\n            // Place a class before a scope identifier.\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n            if (\n            // is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) && (\n            // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\");\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = match[1] == \"+\" ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)) {\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n        return style;\n      },\n      indent: function (state) {\n        return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n      },\n      startState: function (state) {\n        state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n        state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n        state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n        state.tlvInBlockComment = false; // True inside /**/ comment.\n        if (tlvTrackStatements) {\n          state.statementComment = false; // True inside a statement's header comment.\n        }\n      }\n    }\n  });\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConfig","indentUnit","statementIndentUnit","dontAlignCalls","compilerDirectivesUseRegularIndentation","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","compilerDirectiveRegex","RegExp","compilerDirectiveBeginRegex","compilerDirectiveEndRegex","curPunc","curKeyword","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","ch","peek","style","test","next","eatWhile","cur","current","startsWith","endsWith","keywordClose","substr","eatSpace","withSpace","backUp","tokenize","tokenString","eat","tokenComment","skipToEnd","match","quote","escaped","end","maybeEnd","Context","indented","column","type","scopekind","align","prev","pushContext","col","indent","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","isInsideScopeKind","ctx","buildElectricInputRegEx","allClosings","closings","j","push","re","join","electricInput","startState","basecolumn","compilerDirectiveIndented","startOfLine","token","sol","indentation","isClosingAssignment","close","textAfter","Pass","fromHook","firstChar","charAt","closing","possibleClosing","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME","name","tlvIdentifierStyle","tlvScopePrefixChars","tlvIndentUnit","tlvTrackStatements","tlvIdentMatch","tlvFirstLevelIndentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlvScopeStyle","depth","tlvIndentationStyle","tlvIdentNext","tlvInBlockComment","string","tlvCodeActive","pos","blankline","chPos","bodyString","slice","statementComment","pop","tlvNextIndent","beginStatement","eol","prefix","mnemonic","hasOwnProperty"],"sources":["C:/Users/User/Downloads/Salary Payments/node_modules/codemirror/mode/verilog/verilog.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"verilog\", function(config, parserConfig) {\n\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n      // indentation follows the same rules as everything else. Otherwise if\n      // false, compiler directives will track their own indentation.\n      // For example, `ifdef nested inside another `ifndef will be indented,\n      // but a `ifdef inside a function block may not be indented.\n      compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n    \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n    \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n    \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n    \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n    \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n    \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n    \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n    \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n    \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n    \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n    \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n    \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n    \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n    \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n    \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n    \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n    \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n     unary_operator ::=\n       + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_operator ::=\n       + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n       | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n       | -> | <->\n     inc_or_dec_operator ::= ++ | --\n     unary_module_path_operator ::=\n       ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_module_path_operator ::=\n       == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n  var compilerDirectiveRegex      = new RegExp(\n    \"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" +\n    \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n  var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n  var compilerDirectiveEndRegex   = /^(`(?:elsif|else|endif))\\b/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n    \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n  openClose[\"macro_begin\"] = \"macro_end\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n        curKeyword = cur;\n        // Macros that end in _begin, are start of block and end with _end\n        if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n          var keywordClose = curKeyword.substr(0,curKeyword.length - 5) + \"end\";\n          openClose[cur] = keywordClose;\n          curPunc = \"newblock\";\n        } else {\n          stream.eatSpace();\n          if (stream.peek() == '(') {\n            // Check if this is a block\n            curPunc = \"newmacro\";\n          }\n          var withSpace = stream.current();\n          // Move the stream back before the spaces\n          stream.backUp(withSpace.length - cur.length);\n        }\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Event\n    if (ch == '@') {\n      stream.next();\n      stream.eatWhile(/[@]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      curPunc = stream.current();\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n          if (cur === \"fork\") {\n            // Fork can be a statement instead of block in cases of:\n            // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n            stream.eatSpace()\n            if (stream.peek() == ';') {\n              curPunc = \"newstatement\";\n            }\n            stream.backUp(stream.current().length - cur.length);\n          }\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, scopekind, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.scopekind = scopekind;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type, scopekind) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function isInsideScopeKind(ctx, scopekind) {\n    if (ctx == null) {\n      return false;\n    }\n    if (ctx.scopekind === scopekind) {\n      return true;\n    }\n    return isInsideScopeKind(ctx.prev, scopekind);\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n\n    // Regex to force current line to reindent\n    electricInput: buildElectricInputRegEx(),\n\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n        indented: 0,\n        compilerDirectiveIndented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n        if (((curPunc === \"=\") || (curPunc === \"<=\")) && !isInsideScopeKind(ctx, \"assignment\")) {\n          // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n          //      Search through the context to see if we are already in an assignment.\n          // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n          pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n          if (ctx.align == null) ctx.align = true;\n        }\n        return style;\n      }\n      if (ctx.align == null) ctx.align = true;\n\n      var isClosingAssignment = ctx.type == \"assignment\" &&\n        closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n      if (curPunc == ctx.type || isClosingAssignment) {\n        if (isClosingAssignment) {\n          ctx = popContext(state);\n        }\n        ctx = popContext(state);\n        if (curPunc == \")\") {\n          // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n          if (ctx && (ctx.type === \"macro\")) {\n            ctx = popContext(state);\n            while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n          }\n        } else if (curPunc == \"}\") {\n          // Handle closing statements like constraint block: \"foreach () {}\" which\n          // do not have semicolon at end.\n          if (ctx && (ctx.type === \"statement\")) {\n            while (ctx && (ctx.type == \"statement\")) ctx = popContext(state);\n          }\n        }\n      } else if (((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ||\n               (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\", \"case\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\", curKeyword);\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {\n          // Same thing for class (e.g. typedef)\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close, curKeyword);\n        }\n      } else if (curPunc == \"newmacro\" || (curKeyword && curKeyword.match(compilerDirectiveRegex))) {\n        if (curPunc == \"newmacro\") {\n          // Macros (especially if they have parenthesis) potentially have a semicolon\n          // or complete statement/block inside, and should be treated as such.\n          pushContext(state, stream.column(), \"macro\", \"macro\");\n        }\n        if (curKeyword.match(compilerDirectiveEndRegex)) {\n          state.compilerDirectiveIndented -= statementIndentUnit;\n        }\n        if (curKeyword.match(compilerDirectiveBeginRegex)) {\n          state.compilerDirectiveIndented += statementIndentUnit;\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n        if (textAfter.match(compilerDirectiveEndRegex)) {\n          return state.compilerDirectiveIndented - statementIndentUnit;\n        }\n        return state.compilerDirectiveIndented;\n      }\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\")\n        && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\",\n    fold: \"indent\"\n  };\n});\n\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  });\n\n\n\n  // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",  // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",  // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  };\n\n  // Lines starting with these characters define scope (result in indentation).\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/;\n\n\n  // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit;  // TODO: Pass this in instead.\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  }\n\n  // Return true if the next thing in the stream is an identifier with a mnemonic.\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n\n    hooks: {\n\n      electricInput: false,\n\n\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function(stream, state) {\n        var style = undefined;\n        var match;  // Return value of pattern matches.\n\n        // Set highlighting mode based on code region (TLV or SV).\n        if (stream.sol() && ! state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)){\n              state.tlvCodeActive = true;\n            }\n          }\n          // Correct indentation in the face of a line prefix char.\n          if (state.tlvCodeActive && stream.pos == 0 &&\n              (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          }\n\n          // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n              if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                  tlvIdentifierStyle[match[1]])) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit;\n                // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                  if (tlvTrackStatements) {state.statementComment = false;}\n                  depth++;\n                }\n              }\n            }\n            // Clear out deeper indentation levels unless line is blank.\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          }\n          // Set next level of indentation.\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n\n          var beginStatement = false;\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement =\n                   (stream.peek() != \" \") &&   // not a space\n                   (style === undefined) &&    // not a region identifier\n                   !state.tlvInBlockComment && // not in block comment\n                   //!stream.match(tlvCommentMatch, false) && // not comment start\n                   (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n              state.statementComment =\n                   stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\")\n          } else if (((stream.pos / tlvIndentUnit) < state.tlvIndentationStyle.length) &&\n                     (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n                    // codemirror from combining spans\n                    \"tlv-indent-\" + (((stream.pos % 2) == 0) ? \"even\" : \"odd\") +\n                    // and style it\n                    \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\");\n            // Style the line prefix character.\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            }\n            // Place a class before a scope identifier.\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n            if (// is identifier prefix\n                tlvIdentifierStyle.hasOwnProperty(prefix) &&\n                // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n                (mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\")\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = (match[1] == \"+\") ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)){\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n        return style;\n      },\n\n      indent: function(state) {\n        return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n      },\n\n      startState: function(state) {\n        state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n        state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n        state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n        state.tlvInBlockComment = false;  // True inside /**/ comment.\n        if (tlvTrackStatements) {\n          state.statementComment = false;  // True inside a statement's header comment.\n        }\n      }\n\n    }\n  });\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}