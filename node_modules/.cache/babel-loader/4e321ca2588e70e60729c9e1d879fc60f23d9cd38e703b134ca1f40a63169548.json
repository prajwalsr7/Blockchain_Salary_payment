{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*jshint unused:true, eqnull:true, curly:true, bitwise:true */\n/*jshint undef:true, latedef:true, trailing:true */\n/*global CodeMirror:true */\n\n// erlang mode.\n// tokenizer -> token types -> CodeMirror styles\n// tokenizer maintains a parse stack\n// indenter uses the parse stack\n\n// TODO indenter:\n//   bit syntax\n//   old guard/bif/conversion clashes (e.g. \"float/1\")\n//   type/spec/opaque\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMIME(\"text/x-erlang\", \"erlang\");\n  CodeMirror.defineMode(\"erlang\", function (cmCfg) {\n    \"use strict\";\n\n    /////////////////////////////////////////////////////////////////////////////\n    // constants\n    var typeWords = [\"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\n    var keywordWords = [\"after\", \"begin\", \"catch\", \"case\", \"cond\", \"end\", \"fun\", \"if\", \"let\", \"of\", \"query\", \"receive\", \"try\", \"when\"];\n    var separatorRE = /[\\->,;]/;\n    var separatorWords = [\"->\", \";\", \",\"];\n    var operatorAtomWords = [\"and\", \"andalso\", \"band\", \"bnot\", \"bor\", \"bsl\", \"bsr\", \"bxor\", \"div\", \"not\", \"or\", \"orelse\", \"rem\", \"xor\"];\n    var operatorSymbolRE = /[\\+\\-\\*\\/<>=\\|:!]/;\n    var operatorSymbolWords = [\"=\", \"+\", \"-\", \"*\", \"/\", \">\", \">=\", \"<\", \"=<\", \"=:=\", \"==\", \"=/=\", \"/=\", \"||\", \"<-\", \"!\"];\n    var openParenRE = /[<\\(\\[\\{]/;\n    var openParenWords = [\"<<\", \"(\", \"[\", \"{\"];\n    var closeParenRE = /[>\\)\\]\\}]/;\n    var closeParenWords = [\"}\", \"]\", \")\", \">>\"];\n    var guardWords = [\"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_record\", \"is_reference\", \"is_tuple\", \"atom\", \"binary\", \"bitstring\", \"boolean\", \"function\", \"integer\", \"list\", \"number\", \"pid\", \"port\", \"record\", \"reference\", \"tuple\"];\n    var bifWords = [\"abs\", \"adler32\", \"adler32_combine\", \"alive\", \"apply\", \"atom_to_binary\", \"atom_to_list\", \"binary_to_atom\", \"binary_to_existing_atom\", \"binary_to_list\", \"binary_to_term\", \"bit_size\", \"bitstring_to_list\", \"byte_size\", \"check_process_code\", \"contact_binary\", \"crc32\", \"crc32_combine\", \"date\", \"decode_packet\", \"delete_module\", \"disconnect_node\", \"element\", \"erase\", \"exit\", \"float\", \"float_to_list\", \"garbage_collect\", \"get\", \"get_keys\", \"group_leader\", \"halt\", \"hd\", \"integer_to_list\", \"internal_bif\", \"iolist_size\", \"iolist_to_binary\", \"is_alive\", \"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_process_alive\", \"is_record\", \"is_reference\", \"is_tuple\", \"length\", \"link\", \"list_to_atom\", \"list_to_binary\", \"list_to_bitstring\", \"list_to_existing_atom\", \"list_to_float\", \"list_to_integer\", \"list_to_pid\", \"list_to_tuple\", \"load_module\", \"make_ref\", \"module_loaded\", \"monitor_node\", \"node\", \"node_link\", \"node_unlink\", \"nodes\", \"notalive\", \"now\", \"open_port\", \"pid_to_list\", \"port_close\", \"port_command\", \"port_connect\", \"port_control\", \"pre_loaded\", \"process_flag\", \"process_info\", \"processes\", \"purge_module\", \"put\", \"register\", \"registered\", \"round\", \"self\", \"setelement\", \"size\", \"spawn\", \"spawn_link\", \"spawn_monitor\", \"spawn_opt\", \"split_binary\", \"statistics\", \"term_to_binary\", \"time\", \"throw\", \"tl\", \"trunc\", \"tuple_size\", \"tuple_to_list\", \"unlink\", \"unregister\", \"whereis\"];\n\n    // upper case: [A-Z] [Ø-Þ] [À-Ö]\n    // lower case: [a-z] [ß-ö] [ø-ÿ]\n    var anumRE = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\n    var escapesRE = /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // tokenizer\n\n    function tokenizer(stream, state) {\n      // in multi-line string\n      if (state.in_string) {\n        state.in_string = !doubleQuote(stream);\n        return rval(state, stream, \"string\");\n      }\n\n      // in multi-line atom\n      if (state.in_atom) {\n        state.in_atom = !singleQuote(stream);\n        return rval(state, stream, \"atom\");\n      }\n\n      // whitespace\n      if (stream.eatSpace()) {\n        return rval(state, stream, \"whitespace\");\n      }\n\n      // attributes and type specs\n      if (!peekToken(state) && stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n        if (is_member(stream.current(), typeWords)) {\n          return rval(state, stream, \"type\");\n        } else {\n          return rval(state, stream, \"attribute\");\n        }\n      }\n      var ch = stream.next();\n\n      // comment\n      if (ch == '%') {\n        stream.skipToEnd();\n        return rval(state, stream, \"comment\");\n      }\n\n      // colon\n      if (ch == \":\") {\n        return rval(state, stream, \"colon\");\n      }\n\n      // macro\n      if (ch == '?') {\n        stream.eatSpace();\n        stream.eatWhile(anumRE);\n        return rval(state, stream, \"macro\");\n      }\n\n      // record\n      if (ch == \"#\") {\n        stream.eatSpace();\n        stream.eatWhile(anumRE);\n        return rval(state, stream, \"record\");\n      }\n\n      // dollar escape\n      if (ch == \"$\") {\n        if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n          return rval(state, stream, \"error\");\n        }\n        return rval(state, stream, \"number\");\n      }\n\n      // dot\n      if (ch == \".\") {\n        return rval(state, stream, \"dot\");\n      }\n\n      // quoted atom\n      if (ch == '\\'') {\n        if (!(state.in_atom = !singleQuote(stream))) {\n          if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n            stream.match(/\\s*\\/\\s*[0-9]/, true);\n            return rval(state, stream, \"fun\"); // 'f'/0 style fun\n          }\n          if (stream.match(/\\s*\\(/, false) || stream.match(/\\s*:/, false)) {\n            return rval(state, stream, \"function\");\n          }\n        }\n        return rval(state, stream, \"atom\");\n      }\n\n      // string\n      if (ch == '\"') {\n        state.in_string = !doubleQuote(stream);\n        return rval(state, stream, \"string\");\n      }\n\n      // variable\n      if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n        stream.eatWhile(anumRE);\n        return rval(state, stream, \"variable\");\n      }\n\n      // atom/keyword/BIF/function\n      if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n        stream.eatWhile(anumRE);\n        if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n          stream.match(/\\s*\\/\\s*[0-9]/, true);\n          return rval(state, stream, \"fun\"); // f/0 style fun\n        }\n        var w = stream.current();\n        if (is_member(w, keywordWords)) {\n          return rval(state, stream, \"keyword\");\n        } else if (is_member(w, operatorAtomWords)) {\n          return rval(state, stream, \"operator\");\n        } else if (stream.match(/\\s*\\(/, false)) {\n          // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n          if (is_member(w, bifWords) && (peekToken(state).token != \":\" || peekToken(state, 2).token == \"erlang\")) {\n            return rval(state, stream, \"builtin\");\n          } else if (is_member(w, guardWords)) {\n            return rval(state, stream, \"guard\");\n          } else {\n            return rval(state, stream, \"function\");\n          }\n        } else if (lookahead(stream) == \":\") {\n          if (w == \"erlang\") {\n            return rval(state, stream, \"builtin\");\n          } else {\n            return rval(state, stream, \"function\");\n          }\n        } else if (is_member(w, [\"true\", \"false\"])) {\n          return rval(state, stream, \"boolean\");\n        } else {\n          return rval(state, stream, \"atom\");\n        }\n      }\n\n      // number\n      var digitRE = /[0-9]/;\n      var radixRE = /[0-9a-zA-Z]/; // 36#zZ style int\n      if (digitRE.test(ch)) {\n        stream.eatWhile(digitRE);\n        if (stream.eat('#')) {\n          // 36#aZ  style integer\n          if (!stream.eatWhile(radixRE)) {\n            stream.backUp(1); //\"36#\" - syntax error\n          }\n        } else if (stream.eat('.')) {\n          // float\n          if (!stream.eatWhile(digitRE)) {\n            stream.backUp(1); // \"3.\" - probably end of function\n          } else {\n            if (stream.eat(/[eE]/)) {\n              // float with exponent\n              if (stream.eat(/[-+]/)) {\n                if (!stream.eatWhile(digitRE)) {\n                  stream.backUp(2); // \"2e-\" - syntax error\n                }\n              } else {\n                if (!stream.eatWhile(digitRE)) {\n                  stream.backUp(1); // \"2e\" - syntax error\n                }\n              }\n            }\n          }\n        }\n        return rval(state, stream, \"number\"); // normal integer\n      }\n\n      // open parens\n      if (nongreedy(stream, openParenRE, openParenWords)) {\n        return rval(state, stream, \"open_paren\");\n      }\n\n      // close parens\n      if (nongreedy(stream, closeParenRE, closeParenWords)) {\n        return rval(state, stream, \"close_paren\");\n      }\n\n      // separators\n      if (greedy(stream, separatorRE, separatorWords)) {\n        return rval(state, stream, \"separator\");\n      }\n\n      // operators\n      if (greedy(stream, operatorSymbolRE, operatorSymbolWords)) {\n        return rval(state, stream, \"operator\");\n      }\n      return rval(state, stream, null);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // utilities\n    function nongreedy(stream, re, words) {\n      if (stream.current().length == 1 && re.test(stream.current())) {\n        stream.backUp(1);\n        while (re.test(stream.peek())) {\n          stream.next();\n          if (is_member(stream.current(), words)) {\n            return true;\n          }\n        }\n        stream.backUp(stream.current().length - 1);\n      }\n      return false;\n    }\n    function greedy(stream, re, words) {\n      if (stream.current().length == 1 && re.test(stream.current())) {\n        while (re.test(stream.peek())) {\n          stream.next();\n        }\n        while (0 < stream.current().length) {\n          if (is_member(stream.current(), words)) {\n            return true;\n          } else {\n            stream.backUp(1);\n          }\n        }\n        stream.next();\n      }\n      return false;\n    }\n    function doubleQuote(stream) {\n      return quote(stream, '\"', '\\\\');\n    }\n    function singleQuote(stream) {\n      return quote(stream, '\\'', '\\\\');\n    }\n    function quote(stream, quoteChar, escapeChar) {\n      while (!stream.eol()) {\n        var ch = stream.next();\n        if (ch == quoteChar) {\n          return true;\n        } else if (ch == escapeChar) {\n          stream.next();\n        }\n      }\n      return false;\n    }\n    function lookahead(stream) {\n      var m = stream.match(/^\\s*([^\\s%])/, false);\n      return m ? m[1] : \"\";\n    }\n    function is_member(element, list) {\n      return -1 < list.indexOf(element);\n    }\n    function rval(state, stream, type) {\n      // parse stack\n      pushToken(state, realToken(type, stream));\n\n      // map erlang token type to CodeMirror style class\n      //     erlang             -> CodeMirror tag\n      switch (type) {\n        case \"atom\":\n          return \"atom\";\n        case \"attribute\":\n          return \"attribute\";\n        case \"boolean\":\n          return \"atom\";\n        case \"builtin\":\n          return \"builtin\";\n        case \"close_paren\":\n          return null;\n        case \"colon\":\n          return null;\n        case \"comment\":\n          return \"comment\";\n        case \"dot\":\n          return null;\n        case \"error\":\n          return \"error\";\n        case \"fun\":\n          return \"meta\";\n        case \"function\":\n          return \"tag\";\n        case \"guard\":\n          return \"property\";\n        case \"keyword\":\n          return \"keyword\";\n        case \"macro\":\n          return \"variable-2\";\n        case \"number\":\n          return \"number\";\n        case \"open_paren\":\n          return null;\n        case \"operator\":\n          return \"operator\";\n        case \"record\":\n          return \"bracket\";\n        case \"separator\":\n          return null;\n        case \"string\":\n          return \"string\";\n        case \"type\":\n          return \"def\";\n        case \"variable\":\n          return \"variable\";\n        default:\n          return null;\n      }\n    }\n    function aToken(tok, col, ind, typ) {\n      return {\n        token: tok,\n        column: col,\n        indent: ind,\n        type: typ\n      };\n    }\n    function realToken(type, stream) {\n      return aToken(stream.current(), stream.column(), stream.indentation(), type);\n    }\n    function fakeToken(type) {\n      return aToken(type, 0, 0, type);\n    }\n    function peekToken(state, depth) {\n      var len = state.tokenStack.length;\n      var dep = depth ? depth : 1;\n      if (len < dep) {\n        return false;\n      } else {\n        return state.tokenStack[len - dep];\n      }\n    }\n    function pushToken(state, token) {\n      if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n        state.tokenStack = maybe_drop_pre(state.tokenStack, token);\n        state.tokenStack = maybe_drop_post(state.tokenStack);\n      }\n    }\n    function maybe_drop_pre(s, token) {\n      var last = s.length - 1;\n      if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n        s.pop();\n      } else if (0 < last && s[last].type === \"group\") {\n        s.pop();\n        s.push(token);\n      } else {\n        s.push(token);\n      }\n      return s;\n    }\n    function maybe_drop_post(s) {\n      if (!s.length) return s;\n      var last = s.length - 1;\n      if (s[last].type === \"dot\") {\n        return [];\n      }\n      if (last > 1 && s[last].type === \"fun\" && s[last - 1].token === \"fun\") {\n        return s.slice(0, last - 1);\n      }\n      switch (s[last].token) {\n        case \"}\":\n          return d(s, {\n            g: [\"{\"]\n          });\n        case \"]\":\n          return d(s, {\n            i: [\"[\"]\n          });\n        case \")\":\n          return d(s, {\n            i: [\"(\"]\n          });\n        case \">>\":\n          return d(s, {\n            i: [\"<<\"]\n          });\n        case \"end\":\n          return d(s, {\n            i: [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]\n          });\n        case \",\":\n          return d(s, {\n            e: [\"begin\", \"try\", \"when\", \"->\", \",\", \"(\", \"[\", \"{\", \"<<\"]\n          });\n        case \"->\":\n          return d(s, {\n            r: [\"when\"],\n            m: [\"try\", \"if\", \"case\", \"receive\"]\n          });\n        case \";\":\n          return d(s, {\n            E: [\"case\", \"fun\", \"if\", \"receive\", \"try\", \"when\"]\n          });\n        case \"catch\":\n          return d(s, {\n            e: [\"try\"]\n          });\n        case \"of\":\n          return d(s, {\n            e: [\"case\"]\n          });\n        case \"after\":\n          return d(s, {\n            e: [\"receive\", \"try\"]\n          });\n        default:\n          return s;\n      }\n    }\n    function d(stack, tt) {\n      // stack is a stack of Token objects.\n      // tt is an object; {type:tokens}\n      // type is a char, tokens is a list of token strings.\n      // The function returns (possibly truncated) stack.\n      // It will descend the stack, looking for a Token such that Token.token\n      //  is a member of tokens. If it does not find that, it will normally (but\n      //  see \"E\" below) return stack. If it does find a match, it will remove\n      //  all the Tokens between the top and the matched Token.\n      // If type is \"m\", that is all it does.\n      // If type is \"i\", it will also remove the matched Token and the top Token.\n      // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n      // If type is \"r\", it will remove the matched Token, but not the top Token.\n      // If type is \"e\", it will keep the matched Token but not the top Token.\n      // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n      //  in which case it will return an empty stack.\n\n      for (var type in tt) {\n        var len = stack.length - 1;\n        var tokens = tt[type];\n        for (var i = len - 1; -1 < i; i--) {\n          if (is_member(stack[i].token, tokens)) {\n            var ss = stack.slice(0, i);\n            switch (type) {\n              case \"m\":\n                return ss.concat(stack[i]).concat(stack[len]);\n              case \"r\":\n                return ss.concat(stack[len]);\n              case \"i\":\n                return ss;\n              case \"g\":\n                return ss.concat(fakeToken(\"group\"));\n              case \"E\":\n                return ss.concat(stack[i]);\n              case \"e\":\n                return ss.concat(stack[i]);\n            }\n          }\n        }\n      }\n      return type == \"E\" ? [] : stack;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // indenter\n\n    function indenter(state, textAfter) {\n      var t;\n      var unit = cmCfg.indentUnit;\n      var wordAfter = wordafter(textAfter);\n      var currT = peekToken(state, 1);\n      var prevT = peekToken(state, 2);\n      if (state.in_string || state.in_atom) {\n        return CodeMirror.Pass;\n      } else if (!prevT) {\n        return 0;\n      } else if (currT.token == \"when\") {\n        return currT.column + unit;\n      } else if (wordAfter === \"when\" && prevT.type === \"function\") {\n        return prevT.indent + unit;\n      } else if (wordAfter === \"(\" && currT.token === \"fun\") {\n        return currT.column + 3;\n      } else if (wordAfter === \"catch\" && (t = getToken(state, [\"try\"]))) {\n        return t.column;\n      } else if (is_member(wordAfter, [\"end\", \"after\", \"of\"])) {\n        t = getToken(state, [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]);\n        return t ? t.column : CodeMirror.Pass;\n      } else if (is_member(wordAfter, closeParenWords)) {\n        t = getToken(state, openParenWords);\n        return t ? t.column : CodeMirror.Pass;\n      } else if (is_member(currT.token, [\",\", \"|\", \"||\"]) || is_member(wordAfter, [\",\", \"|\", \"||\"])) {\n        t = postcommaToken(state);\n        return t ? t.column + t.token.length : unit;\n      } else if (currT.token == \"->\") {\n        if (is_member(prevT.token, [\"receive\", \"case\", \"if\", \"try\"])) {\n          return prevT.column + unit + unit;\n        } else {\n          return prevT.column + unit;\n        }\n      } else if (is_member(currT.token, openParenWords)) {\n        return currT.column + currT.token.length;\n      } else {\n        t = defaultToken(state);\n        return truthy(t) ? t.column + unit : 0;\n      }\n    }\n    function wordafter(str) {\n      var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n      return truthy(m) && m.index === 0 ? m[0] : \"\";\n    }\n    function postcommaToken(state) {\n      var objs = state.tokenStack.slice(0, -1);\n      var i = getTokenIndex(objs, \"type\", [\"open_paren\"]);\n      return truthy(objs[i]) ? objs[i] : false;\n    }\n    function defaultToken(state) {\n      var objs = state.tokenStack;\n      var stop = getTokenIndex(objs, \"type\", [\"open_paren\", \"separator\", \"keyword\"]);\n      var oper = getTokenIndex(objs, \"type\", [\"operator\"]);\n      if (truthy(stop) && truthy(oper) && stop < oper) {\n        return objs[stop + 1];\n      } else if (truthy(stop)) {\n        return objs[stop];\n      } else {\n        return false;\n      }\n    }\n    function getToken(state, tokens) {\n      var objs = state.tokenStack;\n      var i = getTokenIndex(objs, \"token\", tokens);\n      return truthy(objs[i]) ? objs[i] : false;\n    }\n    function getTokenIndex(objs, propname, propvals) {\n      for (var i = objs.length - 1; -1 < i; i--) {\n        if (is_member(objs[i][propname], propvals)) {\n          return i;\n        }\n      }\n      return false;\n    }\n    function truthy(x) {\n      return x !== false && x != null;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // this object defines the mode\n\n    return {\n      startState: function () {\n        return {\n          tokenStack: [],\n          in_string: false,\n          in_atom: false\n        };\n      },\n      token: function (stream, state) {\n        return tokenizer(stream, state);\n      },\n      indent: function (state, textAfter) {\n        return indenter(state, textAfter);\n      },\n      lineComment: \"%\"\n    };\n  });\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMIME","defineMode","cmCfg","typeWords","keywordWords","separatorRE","separatorWords","operatorAtomWords","operatorSymbolRE","operatorSymbolWords","openParenRE","openParenWords","closeParenRE","closeParenWords","guardWords","bifWords","anumRE","escapesRE","tokenizer","stream","state","in_string","doubleQuote","rval","in_atom","singleQuote","eatSpace","peekToken","match","is_member","current","ch","next","skipToEnd","eatWhile","test","w","token","lookahead","digitRE","radixRE","eat","backUp","nongreedy","greedy","re","words","length","peek","quote","quoteChar","escapeChar","eol","m","element","list","indexOf","type","pushToken","realToken","aToken","tok","col","ind","typ","column","indent","indentation","fakeToken","depth","len","tokenStack","dep","maybe_drop_pre","maybe_drop_post","s","last","pop","push","slice","d","g","i","e","r","E","stack","tt","tokens","ss","concat","indenter","textAfter","t","unit","indentUnit","wordAfter","wordafter","currT","prevT","Pass","getToken","postcommaToken","defaultToken","truthy","str","index","objs","getTokenIndex","stop","oper","propname","propvals","x","startState","lineComment"],"sources":["C:/Users/User/Downloads/Salary Payments/node_modules/codemirror/mode/erlang/erlang.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*jshint unused:true, eqnull:true, curly:true, bitwise:true */\n/*jshint undef:true, latedef:true, trailing:true */\n/*global CodeMirror:true */\n\n// erlang mode.\n// tokenizer -> token types -> CodeMirror styles\n// tokenizer maintains a parse stack\n// indenter uses the parse stack\n\n// TODO indenter:\n//   bit syntax\n//   old guard/bif/conversion clashes (e.g. \"float/1\")\n//   type/spec/opaque\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMIME(\"text/x-erlang\", \"erlang\");\n\nCodeMirror.defineMode(\"erlang\", function(cmCfg) {\n  \"use strict\";\n\n/////////////////////////////////////////////////////////////////////////////\n// constants\n\n  var typeWords = [\n    \"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\n\n  var keywordWords = [\n    \"after\",\"begin\",\"catch\",\"case\",\"cond\",\"end\",\"fun\",\"if\",\n    \"let\",\"of\",\"query\",\"receive\",\"try\",\"when\"];\n\n  var separatorRE    = /[\\->,;]/;\n  var separatorWords = [\n    \"->\",\";\",\",\"];\n\n  var operatorAtomWords = [\n    \"and\",\"andalso\",\"band\",\"bnot\",\"bor\",\"bsl\",\"bsr\",\"bxor\",\n    \"div\",\"not\",\"or\",\"orelse\",\"rem\",\"xor\"];\n\n  var operatorSymbolRE    = /[\\+\\-\\*\\/<>=\\|:!]/;\n  var operatorSymbolWords = [\n    \"=\",\"+\",\"-\",\"*\",\"/\",\">\",\">=\",\"<\",\"=<\",\"=:=\",\"==\",\"=/=\",\"/=\",\"||\",\"<-\",\"!\"];\n\n  var openParenRE    = /[<\\(\\[\\{]/;\n  var openParenWords = [\n    \"<<\",\"(\",\"[\",\"{\"];\n\n  var closeParenRE    = /[>\\)\\]\\}]/;\n  var closeParenWords = [\n    \"}\",\"]\",\")\",\">>\"];\n\n  var guardWords = [\n    \"is_atom\",\"is_binary\",\"is_bitstring\",\"is_boolean\",\"is_float\",\n    \"is_function\",\"is_integer\",\"is_list\",\"is_number\",\"is_pid\",\n    \"is_port\",\"is_record\",\"is_reference\",\"is_tuple\",\n    \"atom\",\"binary\",\"bitstring\",\"boolean\",\"function\",\"integer\",\"list\",\n    \"number\",\"pid\",\"port\",\"record\",\"reference\",\"tuple\"];\n\n  var bifWords = [\n    \"abs\",\"adler32\",\"adler32_combine\",\"alive\",\"apply\",\"atom_to_binary\",\n    \"atom_to_list\",\"binary_to_atom\",\"binary_to_existing_atom\",\n    \"binary_to_list\",\"binary_to_term\",\"bit_size\",\"bitstring_to_list\",\n    \"byte_size\",\"check_process_code\",\"contact_binary\",\"crc32\",\n    \"crc32_combine\",\"date\",\"decode_packet\",\"delete_module\",\n    \"disconnect_node\",\"element\",\"erase\",\"exit\",\"float\",\"float_to_list\",\n    \"garbage_collect\",\"get\",\"get_keys\",\"group_leader\",\"halt\",\"hd\",\n    \"integer_to_list\",\"internal_bif\",\"iolist_size\",\"iolist_to_binary\",\n    \"is_alive\",\"is_atom\",\"is_binary\",\"is_bitstring\",\"is_boolean\",\n    \"is_float\",\"is_function\",\"is_integer\",\"is_list\",\"is_number\",\"is_pid\",\n    \"is_port\",\"is_process_alive\",\"is_record\",\"is_reference\",\"is_tuple\",\n    \"length\",\"link\",\"list_to_atom\",\"list_to_binary\",\"list_to_bitstring\",\n    \"list_to_existing_atom\",\"list_to_float\",\"list_to_integer\",\n    \"list_to_pid\",\"list_to_tuple\",\"load_module\",\"make_ref\",\"module_loaded\",\n    \"monitor_node\",\"node\",\"node_link\",\"node_unlink\",\"nodes\",\"notalive\",\n    \"now\",\"open_port\",\"pid_to_list\",\"port_close\",\"port_command\",\n    \"port_connect\",\"port_control\",\"pre_loaded\",\"process_flag\",\n    \"process_info\",\"processes\",\"purge_module\",\"put\",\"register\",\n    \"registered\",\"round\",\"self\",\"setelement\",\"size\",\"spawn\",\"spawn_link\",\n    \"spawn_monitor\",\"spawn_opt\",\"split_binary\",\"statistics\",\n    \"term_to_binary\",\"time\",\"throw\",\"tl\",\"trunc\",\"tuple_size\",\n    \"tuple_to_list\",\"unlink\",\"unregister\",\"whereis\"];\n\n// upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\n  var anumRE       = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\n  var escapesRE    =\n    /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n/////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\n  function tokenizer(stream,state) {\n    // in multi-line string\n    if (state.in_string) {\n      state.in_string = (!doubleQuote(stream));\n      return rval(state,stream,\"string\");\n    }\n\n    // in multi-line atom\n    if (state.in_atom) {\n      state.in_atom = (!singleQuote(stream));\n      return rval(state,stream,\"atom\");\n    }\n\n    // whitespace\n    if (stream.eatSpace()) {\n      return rval(state,stream,\"whitespace\");\n    }\n\n    // attributes and type specs\n    if (!peekToken(state) &&\n        stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n      if (is_member(stream.current(),typeWords)) {\n        return rval(state,stream,\"type\");\n      }else{\n        return rval(state,stream,\"attribute\");\n      }\n    }\n\n    var ch = stream.next();\n\n    // comment\n    if (ch == '%') {\n      stream.skipToEnd();\n      return rval(state,stream,\"comment\");\n    }\n\n    // colon\n    if (ch == \":\") {\n      return rval(state,stream,\"colon\");\n    }\n\n    // macro\n    if (ch == '?') {\n      stream.eatSpace();\n      stream.eatWhile(anumRE);\n      return rval(state,stream,\"macro\");\n    }\n\n    // record\n    if (ch == \"#\") {\n      stream.eatSpace();\n      stream.eatWhile(anumRE);\n      return rval(state,stream,\"record\");\n    }\n\n    // dollar escape\n    if (ch == \"$\") {\n      if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n        return rval(state,stream,\"error\");\n      }\n      return rval(state,stream,\"number\");\n    }\n\n    // dot\n    if (ch == \".\") {\n      return rval(state,stream,\"dot\");\n    }\n\n    // quoted atom\n    if (ch == '\\'') {\n      if (!(state.in_atom = (!singleQuote(stream)))) {\n        if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n          stream.match(/\\s*\\/\\s*[0-9]/,true);\n          return rval(state,stream,\"fun\");      // 'f'/0 style fun\n        }\n        if (stream.match(/\\s*\\(/,false) || stream.match(/\\s*:/,false)) {\n          return rval(state,stream,\"function\");\n        }\n      }\n      return rval(state,stream,\"atom\");\n    }\n\n    // string\n    if (ch == '\"') {\n      state.in_string = (!doubleQuote(stream));\n      return rval(state,stream,\"string\");\n    }\n\n    // variable\n    if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n      stream.eatWhile(anumRE);\n      return rval(state,stream,\"variable\");\n    }\n\n    // atom/keyword/BIF/function\n    if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n      stream.eatWhile(anumRE);\n\n      if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/,true);\n        return rval(state,stream,\"fun\");      // f/0 style fun\n      }\n\n      var w = stream.current();\n\n      if (is_member(w,keywordWords)) {\n        return rval(state,stream,\"keyword\");\n      }else if (is_member(w,operatorAtomWords)) {\n        return rval(state,stream,\"operator\");\n      }else if (stream.match(/\\s*\\(/,false)) {\n        // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n        if (is_member(w,bifWords) &&\n            ((peekToken(state).token != \":\") ||\n             (peekToken(state,2).token == \"erlang\"))) {\n          return rval(state,stream,\"builtin\");\n        }else if (is_member(w,guardWords)) {\n          return rval(state,stream,\"guard\");\n        }else{\n          return rval(state,stream,\"function\");\n        }\n      }else if (lookahead(stream) == \":\") {\n        if (w == \"erlang\") {\n          return rval(state,stream,\"builtin\");\n        } else {\n          return rval(state,stream,\"function\");\n        }\n      }else if (is_member(w,[\"true\",\"false\"])) {\n        return rval(state,stream,\"boolean\");\n      }else{\n        return rval(state,stream,\"atom\");\n      }\n    }\n\n    // number\n    var digitRE      = /[0-9]/;\n    var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int\n    if (digitRE.test(ch)) {\n      stream.eatWhile(digitRE);\n      if (stream.eat('#')) {                // 36#aZ  style integer\n        if (!stream.eatWhile(radixRE)) {\n          stream.backUp(1);                 //\"36#\" - syntax error\n        }\n      } else if (stream.eat('.')) {       // float\n        if (!stream.eatWhile(digitRE)) {\n          stream.backUp(1);        // \"3.\" - probably end of function\n        } else {\n          if (stream.eat(/[eE]/)) {        // float with exponent\n            if (stream.eat(/[-+]/)) {\n              if (!stream.eatWhile(digitRE)) {\n                stream.backUp(2);            // \"2e-\" - syntax error\n              }\n            } else {\n              if (!stream.eatWhile(digitRE)) {\n                stream.backUp(1);            // \"2e\" - syntax error\n              }\n            }\n          }\n        }\n      }\n      return rval(state,stream,\"number\");   // normal integer\n    }\n\n    // open parens\n    if (nongreedy(stream,openParenRE,openParenWords)) {\n      return rval(state,stream,\"open_paren\");\n    }\n\n    // close parens\n    if (nongreedy(stream,closeParenRE,closeParenWords)) {\n      return rval(state,stream,\"close_paren\");\n    }\n\n    // separators\n    if (greedy(stream,separatorRE,separatorWords)) {\n      return rval(state,stream,\"separator\");\n    }\n\n    // operators\n    if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {\n      return rval(state,stream,\"operator\");\n    }\n\n    return rval(state,stream,null);\n  }\n\n/////////////////////////////////////////////////////////////////////////////\n// utilities\n  function nongreedy(stream,re,words) {\n    if (stream.current().length == 1 && re.test(stream.current())) {\n      stream.backUp(1);\n      while (re.test(stream.peek())) {\n        stream.next();\n        if (is_member(stream.current(),words)) {\n          return true;\n        }\n      }\n      stream.backUp(stream.current().length-1);\n    }\n    return false;\n  }\n\n  function greedy(stream,re,words) {\n    if (stream.current().length == 1 && re.test(stream.current())) {\n      while (re.test(stream.peek())) {\n        stream.next();\n      }\n      while (0 < stream.current().length) {\n        if (is_member(stream.current(),words)) {\n          return true;\n        }else{\n          stream.backUp(1);\n        }\n      }\n      stream.next();\n    }\n    return false;\n  }\n\n  function doubleQuote(stream) {\n    return quote(stream, '\"', '\\\\');\n  }\n\n  function singleQuote(stream) {\n    return quote(stream,'\\'','\\\\');\n  }\n\n  function quote(stream,quoteChar,escapeChar) {\n    while (!stream.eol()) {\n      var ch = stream.next();\n      if (ch == quoteChar) {\n        return true;\n      }else if (ch == escapeChar) {\n        stream.next();\n      }\n    }\n    return false;\n  }\n\n  function lookahead(stream) {\n    var m = stream.match(/^\\s*([^\\s%])/, false)\n    return m ? m[1] : \"\";\n  }\n\n  function is_member(element,list) {\n    return (-1 < list.indexOf(element));\n  }\n\n  function rval(state,stream,type) {\n\n    // parse stack\n    pushToken(state,realToken(type,stream));\n\n    // map erlang token type to CodeMirror style class\n    //     erlang             -> CodeMirror tag\n    switch (type) {\n      case \"atom\":        return \"atom\";\n      case \"attribute\":   return \"attribute\";\n      case \"boolean\":     return \"atom\";\n      case \"builtin\":     return \"builtin\";\n      case \"close_paren\": return null;\n      case \"colon\":       return null;\n      case \"comment\":     return \"comment\";\n      case \"dot\":         return null;\n      case \"error\":       return \"error\";\n      case \"fun\":         return \"meta\";\n      case \"function\":    return \"tag\";\n      case \"guard\":       return \"property\";\n      case \"keyword\":     return \"keyword\";\n      case \"macro\":       return \"variable-2\";\n      case \"number\":      return \"number\";\n      case \"open_paren\":  return null;\n      case \"operator\":    return \"operator\";\n      case \"record\":      return \"bracket\";\n      case \"separator\":   return null;\n      case \"string\":      return \"string\";\n      case \"type\":        return \"def\";\n      case \"variable\":    return \"variable\";\n      default:            return null;\n    }\n  }\n\n  function aToken(tok,col,ind,typ) {\n    return {token:  tok,\n            column: col,\n            indent: ind,\n            type:   typ};\n  }\n\n  function realToken(type,stream) {\n    return aToken(stream.current(),\n                 stream.column(),\n                 stream.indentation(),\n                 type);\n  }\n\n  function fakeToken(type) {\n    return aToken(type,0,0,type);\n  }\n\n  function peekToken(state,depth) {\n    var len = state.tokenStack.length;\n    var dep = (depth ? depth : 1);\n\n    if (len < dep) {\n      return false;\n    }else{\n      return state.tokenStack[len-dep];\n    }\n  }\n\n  function pushToken(state,token) {\n\n    if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n      state.tokenStack = maybe_drop_pre(state.tokenStack,token);\n      state.tokenStack = maybe_drop_post(state.tokenStack);\n    }\n  }\n\n  function maybe_drop_pre(s,token) {\n    var last = s.length-1;\n\n    if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n      s.pop();\n    }else if (0 < last && s[last].type === \"group\") {\n      s.pop();\n      s.push(token);\n    }else{\n      s.push(token);\n    }\n    return s;\n  }\n\n  function maybe_drop_post(s) {\n    if (!s.length) return s\n    var last = s.length-1;\n\n    if (s[last].type === \"dot\") {\n      return [];\n    }\n    if (last > 1 && s[last].type === \"fun\" && s[last-1].token === \"fun\") {\n      return s.slice(0,last-1);\n    }\n    switch (s[last].token) {\n      case \"}\":    return d(s,{g:[\"{\"]});\n      case \"]\":    return d(s,{i:[\"[\"]});\n      case \")\":    return d(s,{i:[\"(\"]});\n      case \">>\":   return d(s,{i:[\"<<\"]});\n      case \"end\":  return d(s,{i:[\"begin\",\"case\",\"fun\",\"if\",\"receive\",\"try\"]});\n      case \",\":    return d(s,{e:[\"begin\",\"try\",\"when\",\"->\",\n                                  \",\",\"(\",\"[\",\"{\",\"<<\"]});\n      case \"->\":   return d(s,{r:[\"when\"],\n                               m:[\"try\",\"if\",\"case\",\"receive\"]});\n      case \";\":    return d(s,{E:[\"case\",\"fun\",\"if\",\"receive\",\"try\",\"when\"]});\n      case \"catch\":return d(s,{e:[\"try\"]});\n      case \"of\":   return d(s,{e:[\"case\"]});\n      case \"after\":return d(s,{e:[\"receive\",\"try\"]});\n      default:     return s;\n    }\n  }\n\n  function d(stack,tt) {\n    // stack is a stack of Token objects.\n    // tt is an object; {type:tokens}\n    // type is a char, tokens is a list of token strings.\n    // The function returns (possibly truncated) stack.\n    // It will descend the stack, looking for a Token such that Token.token\n    //  is a member of tokens. If it does not find that, it will normally (but\n    //  see \"E\" below) return stack. If it does find a match, it will remove\n    //  all the Tokens between the top and the matched Token.\n    // If type is \"m\", that is all it does.\n    // If type is \"i\", it will also remove the matched Token and the top Token.\n    // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n    // If type is \"r\", it will remove the matched Token, but not the top Token.\n    // If type is \"e\", it will keep the matched Token but not the top Token.\n    // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n    //  in which case it will return an empty stack.\n\n    for (var type in tt) {\n      var len = stack.length-1;\n      var tokens = tt[type];\n      for (var i = len-1; -1 < i ; i--) {\n        if (is_member(stack[i].token,tokens)) {\n          var ss = stack.slice(0,i);\n          switch (type) {\n              case \"m\": return ss.concat(stack[i]).concat(stack[len]);\n              case \"r\": return ss.concat(stack[len]);\n              case \"i\": return ss;\n              case \"g\": return ss.concat(fakeToken(\"group\"));\n              case \"E\": return ss.concat(stack[i]);\n              case \"e\": return ss.concat(stack[i]);\n          }\n        }\n      }\n    }\n    return (type == \"E\" ? [] : stack);\n  }\n\n/////////////////////////////////////////////////////////////////////////////\n// indenter\n\n  function indenter(state,textAfter) {\n    var t;\n    var unit = cmCfg.indentUnit;\n    var wordAfter = wordafter(textAfter);\n    var currT = peekToken(state,1);\n    var prevT = peekToken(state,2);\n\n    if (state.in_string || state.in_atom) {\n      return CodeMirror.Pass;\n    }else if (!prevT) {\n      return 0;\n    }else if (currT.token == \"when\") {\n      return currT.column+unit;\n    }else if (wordAfter === \"when\" && prevT.type === \"function\") {\n      return prevT.indent+unit;\n    }else if (wordAfter === \"(\" && currT.token === \"fun\") {\n      return  currT.column+3;\n    }else if (wordAfter === \"catch\" && (t = getToken(state,[\"try\"]))) {\n      return t.column;\n    }else if (is_member(wordAfter,[\"end\",\"after\",\"of\"])) {\n      t = getToken(state,[\"begin\",\"case\",\"fun\",\"if\",\"receive\",\"try\"]);\n      return t ? t.column : CodeMirror.Pass;\n    }else if (is_member(wordAfter,closeParenWords)) {\n      t = getToken(state,openParenWords);\n      return t ? t.column : CodeMirror.Pass;\n    }else if (is_member(currT.token,[\",\",\"|\",\"||\"]) ||\n              is_member(wordAfter,[\",\",\"|\",\"||\"])) {\n      t = postcommaToken(state);\n      return t ? t.column+t.token.length : unit;\n    }else if (currT.token == \"->\") {\n      if (is_member(prevT.token, [\"receive\",\"case\",\"if\",\"try\"])) {\n        return prevT.column+unit+unit;\n      }else{\n        return prevT.column+unit;\n      }\n    }else if (is_member(currT.token,openParenWords)) {\n      return currT.column+currT.token.length;\n    }else{\n      t = defaultToken(state);\n      return truthy(t) ? t.column+unit : 0;\n    }\n  }\n\n  function wordafter(str) {\n    var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n\n    return truthy(m) && (m.index === 0) ? m[0] : \"\";\n  }\n\n  function postcommaToken(state) {\n    var objs = state.tokenStack.slice(0,-1);\n    var i = getTokenIndex(objs,\"type\",[\"open_paren\"]);\n\n    return truthy(objs[i]) ? objs[i] : false;\n  }\n\n  function defaultToken(state) {\n    var objs = state.tokenStack;\n    var stop = getTokenIndex(objs,\"type\",[\"open_paren\",\"separator\",\"keyword\"]);\n    var oper = getTokenIndex(objs,\"type\",[\"operator\"]);\n\n    if (truthy(stop) && truthy(oper) && stop < oper) {\n      return objs[stop+1];\n    } else if (truthy(stop)) {\n      return objs[stop];\n    } else {\n      return false;\n    }\n  }\n\n  function getToken(state,tokens) {\n    var objs = state.tokenStack;\n    var i = getTokenIndex(objs,\"token\",tokens);\n\n    return truthy(objs[i]) ? objs[i] : false;\n  }\n\n  function getTokenIndex(objs,propname,propvals) {\n\n    for (var i = objs.length-1; -1 < i ; i--) {\n      if (is_member(objs[i][propname],propvals)) {\n        return i;\n      }\n    }\n    return false;\n  }\n\n  function truthy(x) {\n    return (x !== false) && (x != null);\n  }\n\n/////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\n  return {\n    startState:\n      function() {\n        return {tokenStack: [],\n                in_string:  false,\n                in_atom:    false};\n      },\n\n    token:\n      function(stream, state) {\n        return tokenizer(stream, state);\n      },\n\n    indent:\n      function(state, textAfter) {\n        return indenter(state,textAfter);\n      },\n\n    lineComment: \"%\"\n  };\n});\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}