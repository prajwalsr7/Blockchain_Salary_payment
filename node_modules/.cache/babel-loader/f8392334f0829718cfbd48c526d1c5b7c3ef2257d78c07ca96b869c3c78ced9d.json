{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"xquery\", function () {\n    // The keywords object is set to the result of this self executing\n    // function. Each keyword is a property of the keywords object whose\n    // value is {type: atype, style: astyle}\n    var keywords = function () {\n      // convenience functions used to build keywords object\n      function kw(type) {\n        return {\n          type: type,\n          style: \"keyword\"\n        };\n      }\n      var operator = kw(\"operator\"),\n        atom = {\n          type: \"atom\",\n          style: \"atom\"\n        },\n        punctuation = {\n          type: \"punctuation\",\n          style: null\n        },\n        qualifier = {\n          type: \"axis_specifier\",\n          style: \"qualifier\"\n        };\n\n      // kwObj is what is return from this function at the end\n      var kwObj = {\n        ',': punctuation\n      };\n\n      // a list of 'basic' keywords. For each add a property to kwObj with the value of\n      // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n      var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as', 'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast', 'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content', 'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete', 'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance', 'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end', 'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling', 'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group', 'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into', 'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map', 'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit', 'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering', 'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve', 'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return', 'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score', 'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable', 'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times', 'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered', 'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version', 'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n      for (var i = 0, l = basic.length; i < l; i++) {\n        kwObj[basic[i]] = kw(basic[i]);\n      }\n      ;\n\n      // a list of types. For each add a property to kwObj with the value of\n      // {type: \"atom\", style: \"atom\"}\n      var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI', 'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp', 'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY', 'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary', 'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language', 'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS', 'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION', 'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string', 'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong', 'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n      for (var i = 0, l = types.length; i < l; i++) {\n        kwObj[types[i]] = atom;\n      }\n      ;\n\n      // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n      var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n      for (var i = 0, l = operators.length; i < l; i++) {\n        kwObj[operators[i]] = operator;\n      }\n      ;\n\n      // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n      var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\", \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n      for (var i = 0, l = axis_specifiers.length; i < l; i++) {\n        kwObj[axis_specifiers[i]] = qualifier;\n      }\n      ;\n      return kwObj;\n    }();\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    }\n\n    // the primary mode tokenizer\n    function tokenBase(stream, state) {\n      var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n      // an XML tag (if not in some sub, chained tokenizer)\n      if (ch == \"<\") {\n        if (stream.match(\"!--\", true)) return chain(stream, state, tokenXMLComment);\n        if (stream.match(\"![CDATA\", false)) {\n          state.tokenize = tokenCDATA;\n          return \"tag\";\n        }\n        if (stream.match(\"?\", false)) {\n          return chain(stream, state, tokenPreProcessing);\n        }\n        var isclose = stream.eat(\"/\");\n        stream.eatSpace();\n        var tagName = \"\",\n          c;\n        while (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) tagName += c;\n        return chain(stream, state, tokenTag(tagName, isclose));\n      }\n      // start code block\n      else if (ch == \"{\") {\n        pushStateStack(state, {\n          type: \"codeblock\"\n        });\n        return null;\n      }\n      // end code block\n      else if (ch == \"}\") {\n        popStateStack(state);\n        return null;\n      }\n      // if we're in an XML block\n      else if (isInXmlBlock(state)) {\n        if (ch == \">\") return \"tag\";else if (ch == \"/\" && stream.eat(\">\")) {\n          popStateStack(state);\n          return \"tag\";\n        } else return \"variable\";\n      }\n      // if a number\n      else if (/\\d/.test(ch)) {\n        stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n        return \"atom\";\n      }\n      // comment start\n      else if (ch === \"(\" && stream.eat(\":\")) {\n        pushStateStack(state, {\n          type: \"comment\"\n        });\n        return chain(stream, state, tokenComment);\n      }\n      // quoted string\n      else if (!isEQName && (ch === '\"' || ch === \"'\")) return chain(stream, state, tokenString(ch));\n      // variable\n      else if (ch === \"$\") {\n        return chain(stream, state, tokenVariable);\n      }\n      // assignment\n      else if (ch === \":\" && stream.eat(\"=\")) {\n        return \"keyword\";\n      }\n      // open paren\n      else if (ch === \"(\") {\n        pushStateStack(state, {\n          type: \"paren\"\n        });\n        return null;\n      }\n      // close paren\n      else if (ch === \")\") {\n        popStateStack(state);\n        return null;\n      }\n      // open paren\n      else if (ch === \"[\") {\n        pushStateStack(state, {\n          type: \"bracket\"\n        });\n        return null;\n      }\n      // close paren\n      else if (ch === \"]\") {\n        popStateStack(state);\n        return null;\n      } else {\n        var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n        // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n        if (isEQName && ch === '\\\"') while (stream.next() !== '\"') {}\n        if (isEQName && ch === '\\'') while (stream.next() !== '\\'') {}\n\n        // gobble up a word if the character is not known\n        if (!known) stream.eatWhile(/[\\w\\$_-]/);\n\n        // gobble a colon in the case that is a lib func type call fn:doc\n        var foundColon = stream.eat(\":\");\n\n        // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n        // which should get matched as a keyword\n        if (!stream.eat(\":\") && foundColon) {\n          stream.eatWhile(/[\\w\\$_-]/);\n        }\n        // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n        if (stream.match(/^[ \\t]*\\(/, false)) {\n          mightBeFunction = true;\n        }\n        // is the word a keyword?\n        var word = stream.current();\n        known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n        // if we think it's a function call but not yet known,\n        // set style to variable for now for lack of something better\n        if (mightBeFunction && !known) known = {\n          type: \"function_call\",\n          style: \"variable def\"\n        };\n\n        // if the previous word was element, attribute, axis specifier, this word should be the name of that\n        if (isInXmlConstructor(state)) {\n          popStateStack(state);\n          return \"variable\";\n        }\n        // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n        // push the stack so we know to look for it on the next word\n        if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {\n          type: \"xmlconstructor\"\n        });\n\n        // if the word is known, return the details of that else just call this a generic 'word'\n        return known ? known.style : \"variable\";\n      }\n    }\n\n    // handle comments, including nested\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n        maybeNested = false,\n        nestedCount = 0,\n        ch;\n      while (ch = stream.next()) {\n        if (ch == \")\" && maybeEnd) {\n          if (nestedCount > 0) nestedCount--;else {\n            popStateStack(state);\n            break;\n          }\n        } else if (ch == \":\" && maybeNested) {\n          nestedCount++;\n        }\n        maybeEnd = ch == \":\";\n        maybeNested = ch == \"(\";\n      }\n      return \"comment\";\n    }\n\n    // tokenizer for string literals\n    // optionally pass a tokenizer function to set state.tokenize back to when finished\n    function tokenString(quote, f) {\n      return function (stream, state) {\n        var ch;\n        if (isInString(state) && stream.current() == quote) {\n          popStateStack(state);\n          if (f) state.tokenize = f;\n          return \"string\";\n        }\n        pushStateStack(state, {\n          type: \"string\",\n          name: quote,\n          tokenize: tokenString(quote, f)\n        });\n\n        // if we're in a string and in an XML block, allow an embedded code block\n        if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n        while (ch = stream.next()) {\n          if (ch == quote) {\n            popStateStack(state);\n            if (f) state.tokenize = f;\n            break;\n          } else {\n            // if we're in a string and in an XML block, allow an embedded code block in an attribute\n            if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n              state.tokenize = tokenBase;\n              return \"string\";\n            }\n          }\n        }\n        return \"string\";\n      };\n    }\n\n    // tokenizer for variables\n    function tokenVariable(stream, state) {\n      var isVariableChar = /[\\w\\$_-]/;\n\n      // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n      if (stream.eat(\"\\\"\")) {\n        while (stream.next() !== '\\\"') {}\n        ;\n        stream.eat(\":\");\n      } else {\n        stream.eatWhile(isVariableChar);\n        if (!stream.match(\":=\", false)) stream.eat(\":\");\n      }\n      stream.eatWhile(isVariableChar);\n      state.tokenize = tokenBase;\n      return \"variable\";\n    }\n\n    // tokenizer for XML tags\n    function tokenTag(name, isclose) {\n      return function (stream, state) {\n        stream.eatSpace();\n        if (isclose && stream.eat(\">\")) {\n          popStateStack(state);\n          state.tokenize = tokenBase;\n          return \"tag\";\n        }\n        // self closing tag without attributes?\n        if (!stream.eat(\"/\")) pushStateStack(state, {\n          type: \"tag\",\n          name: name,\n          tokenize: tokenBase\n        });\n        if (!stream.eat(\">\")) {\n          state.tokenize = tokenAttribute;\n          return \"tag\";\n        } else {\n          state.tokenize = tokenBase;\n        }\n        return \"tag\";\n      };\n    }\n\n    // tokenizer for XML attributes\n    function tokenAttribute(stream, state) {\n      var ch = stream.next();\n      if (ch == \"/\" && stream.eat(\">\")) {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        if (isInXmlBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n      if (ch == \">\") {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n      if (ch == \"=\") return null;\n      // quoted string\n      if (ch == '\"' || ch == \"'\") return chain(stream, state, tokenString(ch, tokenAttribute));\n      if (!isInXmlAttributeBlock(state)) pushStateStack(state, {\n        type: \"attribute\",\n        tokenize: tokenAttribute\n      });\n      stream.eat(/[a-zA-Z_:]/);\n      stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n      stream.eatSpace();\n\n      // the case where the attribute has not value and the tag was closed\n      if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n      }\n      return \"attribute\";\n    }\n\n    // handle comments, including nested\n    function tokenXMLComment(stream, state) {\n      var ch;\n      while (ch = stream.next()) {\n        if (ch == \"-\" && stream.match(\"->\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    }\n\n    // handle CDATA\n    function tokenCDATA(stream, state) {\n      var ch;\n      while (ch = stream.next()) {\n        if (ch == \"]\" && stream.match(\"]\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    }\n\n    // handle preprocessing instructions\n    function tokenPreProcessing(stream, state) {\n      var ch;\n      while (ch = stream.next()) {\n        if (ch == \"?\" && stream.match(\">\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment meta\";\n        }\n      }\n    }\n\n    // functions to test the current context of the state\n    function isInXmlBlock(state) {\n      return isIn(state, \"tag\");\n    }\n    function isInXmlAttributeBlock(state) {\n      return isIn(state, \"attribute\");\n    }\n    function isInXmlConstructor(state) {\n      return isIn(state, \"xmlconstructor\");\n    }\n    function isInString(state) {\n      return isIn(state, \"string\");\n    }\n    function isEQNameAhead(stream) {\n      // assume we've already eaten a quote (\")\n      if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);else return false;\n    }\n    function isIn(state, type) {\n      return state.stack.length && state.stack[state.stack.length - 1].type == type;\n    }\n    function pushStateStack(state, newState) {\n      state.stack.push(newState);\n    }\n    function popStateStack(state) {\n      state.stack.pop();\n      var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n      state.tokenize = reinstateTokenize || tokenBase;\n    }\n\n    // the interface for the mode API\n    return {\n      startState: function () {\n        return {\n          tokenize: tokenBase,\n          cc: [],\n          stack: []\n        };\n      },\n      token: function (stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        return style;\n      },\n      blockCommentStart: \"(:\",\n      blockCommentEnd: \":)\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","keywords","kw","type","style","operator","atom","punctuation","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","tokenString","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","quote","isInString","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","isIn","stack","newState","push","pop","reinstateTokenize","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME"],"sources":["C:/Users/User/Downloads/Multisender-App-main/node_modules/codemirror/mode/xquery/xquery.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xquery\", function() {\n\n  // The keywords object is set to the result of this self executing\n  // function. Each keyword is a property of the keywords object whose\n  // value is {type: atype, style: astyle}\n  var keywords = function(){\n    // convenience functions used to build keywords object\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var operator = kw(\"operator\")\n      , atom = {type: \"atom\", style: \"atom\"}\n      , punctuation = {type: \"punctuation\", style: null}\n      , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n      ',': punctuation\n    };\n\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n    var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n    'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n    'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n    'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n    'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n    'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n    'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n    'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n    'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n    'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n    'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n    'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n    'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n    'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n    'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n    'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n    'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n    'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n    'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n    'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n    'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n    'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n    'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n    'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n    'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n    'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n    'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n    'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n    'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n    \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n    return kwObj;\n  }();\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  // the primary mode tokenizer\n  function tokenBase(stream, state) {\n    var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n      if(stream.match(\"!--\", true))\n        return chain(stream, state, tokenXMLComment);\n\n      if(stream.match(\"![CDATA\", false)) {\n        state.tokenize = tokenCDATA;\n        return \"tag\";\n      }\n\n      if(stream.match(\"?\", false)) {\n        return chain(stream, state, tokenPreProcessing);\n      }\n\n      var isclose = stream.eat(\"/\");\n      stream.eatSpace();\n      var tagName = \"\", c;\n      while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n      return chain(stream, state, tokenTag(tagName, isclose));\n    }\n    // start code block\n    else if(ch == \"{\") {\n      pushStateStack(state, { type: \"codeblock\"});\n      return null;\n    }\n    // end code block\n    else if(ch == \"}\") {\n      popStateStack(state);\n      return null;\n    }\n    // if we're in an XML block\n    else if(isInXmlBlock(state)) {\n      if(ch == \">\")\n        return \"tag\";\n      else if(ch == \"/\" && stream.eat(\">\")) {\n        popStateStack(state);\n        return \"tag\";\n      }\n      else\n        return \"variable\";\n    }\n    // if a number\n    else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n      return \"atom\";\n    }\n    // comment start\n    else if (ch === \"(\" && stream.eat(\":\")) {\n      pushStateStack(state, { type: \"comment\"});\n      return chain(stream, state, tokenComment);\n    }\n    // quoted string\n    else if (!isEQName && (ch === '\"' || ch === \"'\"))\n      return chain(stream, state, tokenString(ch));\n    // variable\n    else if(ch === \"$\") {\n      return chain(stream, state, tokenVariable);\n    }\n    // assignment\n    else if(ch ===\":\" && stream.eat(\"=\")) {\n      return \"keyword\";\n    }\n    // open paren\n    else if(ch === \"(\") {\n      pushStateStack(state, { type: \"paren\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \")\") {\n      popStateStack(state);\n      return null;\n    }\n    // open paren\n    else if(ch === \"[\") {\n      pushStateStack(state, { type: \"bracket\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \"]\") {\n      popStateStack(state);\n      return null;\n    }\n    else {\n      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n      if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n      if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n      // gobble up a word if the character is not known\n      if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n      // gobble a colon in the case that is a lib func type call fn:doc\n      var foundColon = stream.eat(\":\");\n\n      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n      // which should get matched as a keyword\n      if(!stream.eat(\":\") && foundColon) {\n        stream.eatWhile(/[\\w\\$_-]/);\n      }\n      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n      if(stream.match(/^[ \\t]*\\(/, false)) {\n        mightBeFunction = true;\n      }\n      // is the word a keyword?\n      var word = stream.current();\n      known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n      // if we think it's a function call but not yet known,\n      // set style to variable for now for lack of something better\n      if(mightBeFunction && !known) known = {type: \"function_call\", style: \"variable def\"};\n\n      // if the previous word was element, attribute, axis specifier, this word should be the name of that\n      if(isInXmlConstructor(state)) {\n        popStateStack(state);\n        return \"variable\";\n      }\n      // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n      // push the stack so we know to look for it on the next word\n      if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n      // if the word is known, return the details of that else just call this a generic 'word'\n      return known ? known.style : \"variable\";\n    }\n  }\n\n  // handle comments, including nested\n  function tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while (ch = stream.next()) {\n      if (ch == \")\" && maybeEnd) {\n        if(nestedCount > 0)\n          nestedCount--;\n        else {\n          popStateStack(state);\n          break;\n        }\n      }\n      else if(ch == \":\" && maybeNested) {\n        nestedCount++;\n      }\n      maybeEnd = (ch == \":\");\n      maybeNested = (ch == \"(\");\n    }\n\n    return \"comment\";\n  }\n\n  // tokenizer for string literals\n  // optionally pass a tokenizer function to set state.tokenize back to when finished\n  function tokenString(quote, f) {\n    return function(stream, state) {\n      var ch;\n\n      if(isInString(state) && stream.current() == quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        return \"string\";\n      }\n\n      pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n      // if we're in a string and in an XML block, allow an embedded code block\n      if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n\n\n      while (ch = stream.next()) {\n        if (ch ==  quote) {\n          popStateStack(state);\n          if(f) state.tokenize = f;\n          break;\n        }\n        else {\n          // if we're in a string and in an XML block, allow an embedded code block in an attribute\n          if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n            state.tokenize = tokenBase;\n            return \"string\";\n          }\n\n        }\n      }\n\n      return \"string\";\n    };\n  }\n\n  // tokenizer for variables\n  function tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if(stream.eat(\"\\\"\")) {\n      while(stream.next() !== '\\\"'){};\n      stream.eat(\":\");\n    } else {\n      stream.eatWhile(isVariableChar);\n      if(!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = tokenBase;\n    return \"variable\";\n  }\n\n  // tokenizer for XML tags\n  function tokenTag(name, isclose) {\n    return function(stream, state) {\n      stream.eatSpace();\n      if(isclose && stream.eat(\">\")) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n        return \"tag\";\n      }\n      // self closing tag without attributes?\n      if(!stream.eat(\"/\"))\n        pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n      if(!stream.eat(\">\")) {\n        state.tokenize = tokenAttribute;\n        return \"tag\";\n      }\n      else {\n        state.tokenize = tokenBase;\n      }\n      return \"tag\";\n    };\n  }\n\n  // tokenizer for XML attributes\n  function tokenAttribute(stream, state) {\n    var ch = stream.next();\n\n    if(ch == \"/\" && stream.eat(\">\")) {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      if(isInXmlBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \">\") {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \"=\")\n      return null;\n    // quoted string\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, tokenString(ch, tokenAttribute));\n\n    if(!isInXmlAttributeBlock(state))\n      pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n\n    // the case where the attribute has not value and the tag was closed\n    if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n    }\n\n    return \"attribute\";\n  }\n\n  // handle comments, including nested\n  function tokenXMLComment(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n\n  // handle CDATA\n  function tokenCDATA(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n  // handle preprocessing instructions\n  function tokenPreProcessing(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment meta\";\n      }\n    }\n  }\n\n\n  // functions to test the current context of the state\n  function isInXmlBlock(state) { return isIn(state, \"tag\"); }\n  function isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\n  function isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\n  function isInString(state) { return isIn(state, \"string\"); }\n\n  function isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if(stream.current() === '\"')\n      return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if(stream.current() === '\\'')\n      return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else\n      return false;\n  }\n\n  function isIn(state, type) {\n    return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n  }\n\n  function pushStateStack(state, newState) {\n    state.stack.push(newState);\n  }\n\n  function popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n    state.tokenize = reinstateTokenize || tokenBase;\n  }\n\n  // the interface for the mode API\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        cc: [],\n        stack: []\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      return style;\n    },\n\n    blockCommentStart: \"(:\",\n    blockCommentEnd: \":)\"\n\n  };\n\n});\n\nCodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}