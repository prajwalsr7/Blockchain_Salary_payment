{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function (config) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"htmlmixed\"\n    });\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = {\n      html: htmlMode,\n      ruby: rubyMode\n    };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\",\n      // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\",\n      // no highlighting so far\n      creole: \"text/x-creole\",\n      // no highlighting so far\n      wiki: \"text/x-wiki\",\n      // no highlighting so far\n      mediawiki: \"text/x-mediawiki\",\n      // no highlighting so far\n      rdoc: \"text/x-rdoc\",\n      // no highlighting so far\n      builder: \"text/x-builder\",\n      // no highlighting so far\n      nokogiri: \"text/x-nokogiri\",\n      // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n    var embeddedRegexp = function (map) {\n      var arr = [];\n      for (var key in map) arr.push(key);\n      return new RegExp(\"^(\" + arr.join('|') + \"):\");\n    }(embedded);\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\" + nameStartChar + \"](?::[\" + nameChar + \"]|[\" + nameChar + \"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\" + nameStartChar + \"][:\\\\.\" + nameChar + \"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\" + nameStartChar + \"][:\\\\.\" + nameChar + \"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n    function backup(pos, tokenize, style) {\n      var restore = function (stream, state) {\n        state.tokenize = tokenize;\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n        return state.tokenize(stream, state);\n      };\n      return function (stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n      return style;\n    }\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n    function lineContinuable(column, tokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function commaContinuable(column, tokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n        return style;\n      };\n    }\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function (stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n    function startRubySplat(tokenize) {\n      var rubyState;\n      var runSplat = function (stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n          stream.next();\n        }\n        return ruby(stream, state);\n      };\n      return function (stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n      return html(stream, state);\n    }\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n    function startHtmlLine(lastTokenize) {\n      return function (stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset,\n        // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n      stream.next();\n      return null;\n    }\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n      return attributeWrapper(stream, state);\n    }\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n      var factory = CodeMirror.modes[query];\n      if (factory) {\n        return factory(config, {\n          name: query\n        });\n      }\n      return CodeMirror.getMode(config, \"null\");\n    }\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n      return modes[mode];\n    }\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n      state.subMode = subMode;\n      state.subState = subState;\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n    function startLine(stream, state) {\n      var ch = stream.peek();\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n      var m = stream.match(embeddedRegexp);\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n      return slimTag(stream, state);\n    }\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n      return slimTag(stream, state);\n    }\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n      return slimClass(stream, state);\n    }\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n      return slimClass(stream, state);\n    }\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n      return slimAttribute(stream, state);\n    }\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n      return slimContent(stream, state);\n    }\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      }\n      // should never happen, because of forward lookup\n      return slimAttribute(stream, state);\n    }\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n        var escaped = false,\n          ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^\\/$/)) {\n        // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n      if (stream.match(/^:/)) {\n        // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n    var mode = {\n      // default to html mode\n      startState: function () {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n      copyState: function (state) {\n        return {\n          htmlState: CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n      token: function (stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n      blankLine: function (state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n      innerMode: function (state) {\n        if (state.subMode) return {\n          state: state.subState,\n          mode: state.subMode\n        };\n        return {\n          state: state,\n          mode: mode\n        };\n      }\n\n      //indent: function(state) {\n      //  return state.indented;\n      //}\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","htmlMode","getMode","name","rubyMode","modes","html","ruby","embedded","javascript","css","sass","scss","less","styl","coffee","asciidoc","markdown","textile","creole","wiki","mediawiki","rdoc","builder","nokogiri","erb","embeddedRegexp","map","arr","key","push","RegExp","join","styleMap","closing","nameStartChar","nameChar","nameRegexp","attributeNameRegexp","wrappedAttributeNameRegexp","classNameRegexp","classIdRegexp","backup","pos","tokenize","style","restore","stream","state","maybeBackup","pat","offset","cur","current","idx","search","backUp","length","continueLine","column","stack","parent","indented","line","finishContinue","lineContinuable","match","eol","commaContinuable","rubyInQuote","endQuote","ch","peek","rubyState","next","startRubySplat","runSplat","context","prev","eatSpace","startState","token","htmlLine","htmlState","startHtmlLine","lastTokenize","startHtmlMode","comment","skipToEnd","commentMode","attributeWrapper","eat","attributeWrapperAssign","attributeWrapperValue","readQuoted","startAttributeWrapperMode","sub","subStream","StringStream","string","slice","tabSize","start","lastColumnPos","lastColumnValue","subMode","subState","firstSub","createMode","mode","query","spec","mimeModes","factory","hasOwnProperty","startSubMode","doctypeLine","_state","startLine","m","slimTag","slim","startOfLine","slimTagExtras","slimClass","slimAttribute","$1","slimAttributeAssign","slimContent","slimAttributeValue","slimAttributeSymbols","quote","embed","unescaped","nextTokenize","fresh","escaped","last","copyState","sol","indentation","blankLine","innerMode","defineMIME"],"sources":["C:/Users/User/Downloads/Salary Payments/node_modules/codemirror/mode/slim/slim.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = { html: htmlMode, ruby: rubyMode };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\", // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\", // no highlighting so far\n      creole: \"text/x-creole\", // no highlighting so far\n      wiki: \"text/x-wiki\", // no highlighting so far\n      mediawiki: \"text/x-mediawiki\", // no highlighting so far\n      rdoc: \"text/x-rdoc\", // no highlighting so far\n      builder: \"text/x-builder\", // no highlighting so far\n      nokogiri: \"text/x-nokogiri\", // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n    var embeddedRegexp = function(map){\n      var arr = [];\n      for(var key in map) arr.push(key);\n      return new RegExp(\"^(\"+arr.join('|')+\"):\");\n    }(embedded);\n\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\"+nameStartChar+\"](?::[\"+nameChar+\"]|[\"+nameChar+\"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n\n    function backup(pos, tokenize, style) {\n      var restore = function(stream, state) {\n        state.tokenize = tokenize;\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n        return state.tokenize(stream, state);\n      };\n      return function(stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n      return style;\n    }\n\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n\n    function lineContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function commaContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n        return style;\n      };\n    }\n\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n    function startRubySplat(tokenize) {\n      var rubyState;\n      var runSplat = function(stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n          stream.next();\n        }\n        return ruby(stream, state);\n      };\n      return function(stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n      return html(stream, state);\n    }\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n\n    function startHtmlLine(lastTokenize) {\n      return function(stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset, // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n      stream.next();\n      return null;\n    }\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n      return attributeWrapper(stream, state);\n    }\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n      var factory = CodeMirror.modes[query];\n      if (factory) {\n        return factory(config, {name: query});\n      }\n      return CodeMirror.getMode(config, \"null\");\n    }\n\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n      return modes[mode];\n    }\n\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n\n      state.subMode = subMode;\n      state.subState = subState;\n\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n\n    function startLine(stream, state) {\n      var ch = stream.peek();\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n\n      var m = stream.match(embeddedRegexp);\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n      return slimTag(stream, state);\n    }\n\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n      return slimClass(stream, state);\n    }\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n      return slimClass(stream, state);\n    }\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n      return slimAttribute(stream, state);\n    }\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n      return slimContent(stream, state);\n    }\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      }\n      // should never happen, because of forward lookup\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n        var escaped = false, ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^\\/$/)) { // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n      if (stream.match(/^:/)) { // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n\n    var mode = {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n\n      blankLine: function(state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n\n      innerMode: function(state) {\n        if (state.subMode) return {state: state.subState, mode: state.subMode};\n        return {state: state, mode: mode};\n      }\n\n      //indent: function(state) {\n      //  return state.indented;\n      //}\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}