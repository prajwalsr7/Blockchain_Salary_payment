{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"oz\", function (conf) {\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n    var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n    var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n    var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n    var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n    var end = [\"end\"];\n    var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n    var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n    var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n    var middleKeywords = wordRegexp(middle);\n    var endKeywords = wordRegexp(end);\n\n    // Tokenizers\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      // Brackets\n      if (stream.match(/[{}]/)) {\n        return \"bracket\";\n      }\n\n      // Special [] keyword\n      if (stream.match('[]')) {\n        return \"keyword\";\n      }\n\n      // Operators\n      if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n        return \"operator\";\n      }\n\n      // Atoms\n      if (stream.match(atoms)) {\n        return 'atom';\n      }\n\n      // Opening keywords\n      var matched = stream.match(openingKeywords);\n      if (matched) {\n        if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false;\n\n        // Special matching for signatures\n        if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n        return 'keyword';\n      }\n\n      // Middle and other keywords\n      if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n        return \"keyword\";\n      }\n\n      // End keywords\n      if (stream.match(endKeywords)) {\n        state.currentIndent--;\n        return 'keyword';\n      }\n\n      // Eat the next char for next comparisons\n      var ch = stream.next();\n\n      // Strings\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      // Numbers\n      if (/[~\\d]/.test(ch)) {\n        if (ch == \"~\") {\n          if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        }\n        if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        return null;\n      }\n\n      // Comments\n      if (ch == \"%\") {\n        stream.skipToEnd();\n        return 'comment';\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n      }\n\n      // Single operators\n      if (singleOperators.test(ch)) {\n        return \"operator\";\n      }\n\n      // If nothing match, we skip the entire alphanumeric block\n      stream.eatWhile(/\\w/);\n      return \"variable\";\n    }\n    function tokenClass(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"variable-3\";\n    }\n    function tokenMeth(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n      stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"def\";\n    }\n    function tokenFunProc(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n      if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n        state.hasPassedFirstStage = true;\n        return \"bracket\";\n      } else if (state.hasPassedFirstStage) {\n        stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n        state.hasPassedFirstStage = false;\n        state.tokenize = tokenBase;\n        return \"def\";\n      } else {\n        state.tokenize = tokenBase;\n        return null;\n      }\n    }\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n        ch;\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        maybeEnd = ch == \"*\";\n      }\n      return \"comment\";\n    }\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n          next,\n          end = false;\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n        if (end || !escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on [] or on a match of any of\n      // the block closing keywords, at the end of a line.\n      var allClosings = middle.concat(end);\n      return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    }\n    return {\n      startState: function () {\n        return {\n          tokenize: tokenBase,\n          currentIndent: 0,\n          doInCurrentLine: false,\n          hasPassedFirstStage: false\n        };\n      },\n      token: function (stream, state) {\n        if (stream.sol()) state.doInCurrentLine = 0;\n        return state.tokenize(stream, state);\n      },\n      indent: function (state, textAfter) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return conf.indentUnit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * conf.indentUnit;\n      },\n      fold: \"indent\",\n      electricInput: buildElectricInputRegEx(),\n      lineComment: \"%\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","conf","wordRegexp","words","RegExp","join","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","ch","next","tokenString","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","quote","escaped","buildElectricInputRegEx","allClosings","concat","startState","token","sol","indent","textAfter","trueText","replace","indentUnit","fold","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME"],"sources":["C:/Users/User/Downloads/Salary Payments/node_modules/codemirror/mode/oz/oz.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"oz\", function (conf) {\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n  var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n  var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n\n  var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\",\n    \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n  var end = [\"end\"];\n\n  var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n  var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\",\n    \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n  var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\",\n    \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n  var middleKeywords = wordRegexp(middle);\n  var endKeywords = wordRegexp(end);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    // Brackets\n    if(stream.match(/[{}]/)) {\n      return \"bracket\";\n    }\n\n    // Special [] keyword\n    if (stream.match('[]')) {\n        return \"keyword\"\n    }\n\n    // Operators\n    if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n      return \"operator\";\n    }\n\n    // Atoms\n    if(stream.match(atoms)) {\n      return 'atom';\n    }\n\n    // Opening keywords\n    var matched = stream.match(openingKeywords);\n    if (matched) {\n      if (!state.doInCurrentLine)\n        state.currentIndent++;\n      else\n        state.doInCurrentLine = false;\n\n      // Special matching for signatures\n      if(matched[0] == \"proc\" || matched[0] == \"fun\")\n        state.tokenize = tokenFunProc;\n      else if(matched[0] == \"class\")\n        state.tokenize = tokenClass;\n      else if(matched[0] == \"meth\")\n        state.tokenize = tokenMeth;\n\n      return 'keyword';\n    }\n\n    // Middle and other keywords\n    if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n      return \"keyword\"\n    }\n\n    // End keywords\n    if (stream.match(endKeywords)) {\n      state.currentIndent--;\n      return 'keyword';\n    }\n\n    // Eat the next char for next comparisons\n    var ch = stream.next();\n\n    // Strings\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n\n    // Numbers\n    if (/[~\\d]/.test(ch)) {\n      if (ch == \"~\") {\n        if(! /^[0-9]/.test(stream.peek()))\n          return null;\n        else if (( stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n          return \"number\";\n      }\n\n      if ((ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n        return \"number\";\n\n      return null;\n    }\n\n    // Comments\n    if (ch == \"%\") {\n      stream.skipToEnd();\n      return 'comment';\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n    }\n\n    // Single operators\n    if(singleOperators.test(ch)) {\n      return \"operator\";\n    }\n\n    // If nothing match, we skip the entire alphanumeric block\n    stream.eatWhile(/\\w/);\n\n    return \"variable\";\n  }\n\n  function tokenClass(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"variable-3\"\n  }\n\n  function tokenMeth(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"def\"\n  }\n\n  function tokenFunProc(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    if(!state.hasPassedFirstStage && stream.eat(\"{\")) {\n      state.hasPassedFirstStage = true;\n      return \"bracket\";\n    }\n    else if(state.hasPassedFirstStage) {\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n      state.hasPassedFirstStage = false;\n      state.tokenize = tokenBase;\n      return \"def\"\n    }\n    else {\n      state.tokenize = tokenBase;\n      return null;\n    }\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          end = true;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !escaped)\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on [] or on a match of any of\n    // the block closing keywords, at the end of a line.\n    var allClosings = middle.concat(end);\n    return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n  }\n\n  return {\n\n    startState: function () {\n      return {\n        tokenize: tokenBase,\n        currentIndent: 0,\n        doInCurrentLine: false,\n        hasPassedFirstStage: false\n      };\n    },\n\n    token: function (stream, state) {\n      if (stream.sol())\n        state.doInCurrentLine = 0;\n\n      return state.tokenize(stream, state);\n    },\n\n    indent: function (state, textAfter) {\n      var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n\n      if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/))\n        return conf.indentUnit * (state.currentIndent - 1);\n\n      if (state.currentIndent < 0)\n        return 0;\n\n      return state.currentIndent * conf.indentUnit;\n    },\n    fold: \"indent\",\n    electricInput: buildElectricInputRegEx(),\n    lineComment: \"%\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}