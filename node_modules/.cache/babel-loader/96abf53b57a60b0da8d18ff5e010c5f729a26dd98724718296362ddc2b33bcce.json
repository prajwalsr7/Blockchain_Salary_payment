{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n */\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\",\n      COMMENT = \"comment\",\n      STRING = \"string\",\n      ATOM = \"atom\",\n      NUMBER = \"number\",\n      BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n    function makeKeywords(str) {\n      var obj = {},\n        words = str.split(\" \");\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n      return obj;\n    }\n    var keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n    function stateStack(indent, type, prev) {\n      // represents a state stack object\n      this.indent = indent;\n      this.type = type;\n      this.prev = prev;\n    }\n    function pushStack(state, indent, type) {\n      state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n    function popStack(state) {\n      state.indentStack = state.indentStack.prev;\n    }\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n    function isBinaryNumber(stream) {\n      return stream.match(binaryMatcher);\n    }\n    function isOctalNumber(stream) {\n      return stream.match(octalMatcher);\n    }\n    function isDecimalNumber(stream, backup) {\n      if (backup === true) {\n        stream.backUp(1);\n      }\n      return stream.match(decimalMatcher);\n    }\n    function isHexNumber(stream) {\n      return stream.match(hexMatcher);\n    }\n    return {\n      startState: function () {\n        return {\n          indentStack: null,\n          indentation: 0,\n          mode: false,\n          sExprComment: false,\n          sExprQuote: false\n        };\n      },\n      token: function (stream, state) {\n        if (state.indentStack == null && stream.sol()) {\n          // update indentation, but only if indentStack is empty\n          state.indentation = stream.indentation();\n        }\n\n        // skip spaces\n        if (stream.eatSpace()) {\n          return null;\n        }\n        var returnType = null;\n        switch (state.mode) {\n          case \"string\":\n            // multi-line string parsing mode\n            var next,\n              escaped = false;\n            while ((next = stream.next()) != null) {\n              if (next == \"\\\"\" && !escaped) {\n                state.mode = false;\n                break;\n              }\n              escaped = !escaped && next == \"\\\\\";\n            }\n            returnType = STRING; // continue on in scheme-string mode\n            break;\n          case \"comment\":\n            // comment parsing mode\n            var next,\n              maybeEnd = false;\n            while ((next = stream.next()) != null) {\n              if (next == \"#\" && maybeEnd) {\n                state.mode = false;\n                break;\n              }\n              maybeEnd = next == \"|\";\n            }\n            returnType = COMMENT;\n            break;\n          case \"s-expr-comment\":\n            // s-expr commenting mode\n            state.mode = false;\n            if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n              // actually start scheme s-expr commenting mode\n              state.sExprComment = 0;\n            } else {\n              // if not we just comment the entire of the next token\n              stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n              returnType = COMMENT;\n              break;\n            }\n          default:\n            // default parsing mode\n            var ch = stream.next();\n            if (ch == \"\\\"\") {\n              state.mode = \"string\";\n              returnType = STRING;\n            } else if (ch == \"'\") {\n              if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n                if (typeof state.sExprQuote != \"number\") {\n                  state.sExprQuote = 0;\n                } // else already in a quoted expression\n                returnType = ATOM;\n              } else {\n                stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                returnType = ATOM;\n              }\n            } else if (ch == '#') {\n              if (stream.eat(\"|\")) {\n                // Multi-line comment\n                state.mode = \"comment\"; // toggle to comment mode\n                returnType = COMMENT;\n              } else if (stream.eat(/[tf]/i)) {\n                // #t/#f (atom)\n                returnType = ATOM;\n              } else if (stream.eat(';')) {\n                // S-Expr comment\n                state.mode = \"s-expr-comment\";\n                returnType = COMMENT;\n              } else {\n                var numTest = null,\n                  hasExactness = false,\n                  hasRadix = true;\n                if (stream.eat(/[ei]/i)) {\n                  hasExactness = true;\n                } else {\n                  stream.backUp(1); // must be radix specifier\n                }\n                if (stream.match(/^#b/i)) {\n                  numTest = isBinaryNumber;\n                } else if (stream.match(/^#o/i)) {\n                  numTest = isOctalNumber;\n                } else if (stream.match(/^#x/i)) {\n                  numTest = isHexNumber;\n                } else if (stream.match(/^#d/i)) {\n                  numTest = isDecimalNumber;\n                } else if (stream.match(/^[-+0-9.]/, false)) {\n                  hasRadix = false;\n                  numTest = isDecimalNumber;\n                  // re-consume the initial # if all matches failed\n                } else if (!hasExactness) {\n                  stream.eat('#');\n                }\n                if (numTest != null) {\n                  if (hasRadix && !hasExactness) {\n                    // consume optional exactness after radix\n                    stream.match(/^#[ei]/i);\n                  }\n                  if (numTest(stream)) returnType = NUMBER;\n                }\n              }\n            } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) {\n              // match non-prefixed number, must be decimal\n              returnType = NUMBER;\n            } else if (ch == \";\") {\n              // comment\n              stream.skipToEnd(); // rest of the line is a comment\n              returnType = COMMENT;\n            } else if (ch == \"(\" || ch == \"[\") {\n              var keyWord = '';\n              var indentTemp = stream.column(),\n                letter;\n              /**\n              Either\n              (indent-word ..\n              (non-indent-word ..\n              (;something else, bracket, etc.\n              */\n\n              while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                keyWord += letter;\n              }\n              if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) {\n                // indent-word\n\n                pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n              } else {\n                // non-indent word\n                // we continue eating the spaces\n                stream.eatSpace();\n                if (stream.eol() || stream.peek() == \";\") {\n                  // nothing significant after\n                  // we restart indentation 1 space after\n                  pushStack(state, indentTemp + 1, ch);\n                } else {\n                  pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                }\n              }\n              stream.backUp(stream.current().length - 1); // undo all the eating\n\n              if (typeof state.sExprComment == \"number\") state.sExprComment++;\n              if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n              returnType = BRACKET;\n            } else if (ch == \")\" || ch == \"]\") {\n              returnType = BRACKET;\n              if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                popStack(state);\n                if (typeof state.sExprComment == \"number\") {\n                  if (--state.sExprComment == 0) {\n                    returnType = COMMENT; // final closing bracket\n                    state.sExprComment = false; // turn off s-expr commenting mode\n                  }\n                }\n                if (typeof state.sExprQuote == \"number\") {\n                  if (--state.sExprQuote == 0) {\n                    returnType = ATOM; // final closing bracket\n                    state.sExprQuote = false; // turn off s-expr quote mode\n                  }\n                }\n              }\n            } else {\n              stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n              if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                returnType = BUILTIN;\n              } else returnType = \"variable\";\n            }\n        }\n        return typeof state.sExprComment == \"number\" ? COMMENT : typeof state.sExprQuote == \"number\" ? ATOM : returnType;\n      },\n      indent: function (state) {\n        if (state.indentStack == null) return state.indentation;\n        return state.indentStack.indent;\n      },\n      closeBrackets: {\n        pairs: \"()[]{}\\\"\\\"\"\n      },\n      lineComment: \";;\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","BUILTIN","COMMENT","STRING","ATOM","NUMBER","BRACKET","INDENT_WORD_SKIP","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","pushStack","state","indentStack","popStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","startState","indentation","mode","sExprComment","sExprQuote","token","sol","eatSpace","returnType","next","escaped","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","eol","current","closeBrackets","pairs","lineComment","defineMIME"],"sources":["C:/Users/User/Downloads/Multisender-App-main/node_modules/codemirror/mode/scheme/scheme.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber (stream) {\n        return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber (stream) {\n        return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber (stream, backup) {\n        if (backup === true) {\n            stream.backUp(1);\n        }\n        return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber (stream) {\n        return stream.match(hexMatcher);\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false,\n                sExprComment: false,\n                sExprQuote: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in scheme-string mode\n                    break;\n                case \"comment\": // comment parsing mode\n                    var next, maybeEnd = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"#\" && maybeEnd) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        maybeEnd = (next == \"|\");\n                    }\n                    returnType = COMMENT;\n                    break;\n                case \"s-expr-comment\": // s-expr commenting mode\n                    state.mode = false;\n                    if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n                        // actually start scheme s-expr commenting mode\n                        state.sExprComment = 0;\n                    }else{\n                        // if not we just comment the entire of the next token\n                        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n                        returnType = COMMENT;\n                        break;\n                    }\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n\n                    } else if (ch == \"'\") {\n                        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n                            if (typeof state.sExprQuote != \"number\") {\n                                state.sExprQuote = 0;\n                            } // else already in a quoted expression\n                            returnType = ATOM;\n                        } else {\n                            stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                            returnType = ATOM;\n                        }\n                    } else if (ch == '#') {\n                        if (stream.eat(\"|\")) {                    // Multi-line comment\n                            state.mode = \"comment\"; // toggle to comment mode\n                            returnType = COMMENT;\n                        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n                            returnType = ATOM;\n                        } else if (stream.eat(';')) {                // S-Expr comment\n                            state.mode = \"s-expr-comment\";\n                            returnType = COMMENT;\n                        } else {\n                            var numTest = null, hasExactness = false, hasRadix = true;\n                            if (stream.eat(/[ei]/i)) {\n                                hasExactness = true;\n                            } else {\n                                stream.backUp(1);       // must be radix specifier\n                            }\n                            if (stream.match(/^#b/i)) {\n                                numTest = isBinaryNumber;\n                            } else if (stream.match(/^#o/i)) {\n                                numTest = isOctalNumber;\n                            } else if (stream.match(/^#x/i)) {\n                                numTest = isHexNumber;\n                            } else if (stream.match(/^#d/i)) {\n                                numTest = isDecimalNumber;\n                            } else if (stream.match(/^[-+0-9.]/, false)) {\n                                hasRadix = false;\n                                numTest = isDecimalNumber;\n                            // re-consume the initial # if all matches failed\n                            } else if (!hasExactness) {\n                                stream.eat('#');\n                            }\n                            if (numTest != null) {\n                                if (hasRadix && !hasExactness) {\n                                    // consume optional exactness after radix\n                                    stream.match(/^#[ei]/i);\n                                }\n                                if (numTest(stream))\n                                    returnType = NUMBER;\n                            }\n                        }\n                    } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n                        returnType = NUMBER;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (ch == \"(\" || ch == \"[\") {\n                      var keyWord = ''; var indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation 1 space after\n                                pushStack(state, indentTemp + 1, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n                        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                            popStack(state);\n\n                            if(typeof state.sExprComment == \"number\"){\n                                if(--state.sExprComment == 0){\n                                    returnType = COMMENT; // final closing bracket\n                                    state.sExprComment = false; // turn off s-expr commenting mode\n                                }\n                            }\n                            if(typeof state.sExprQuote == \"number\"){\n                                if(--state.sExprQuote == 0){\n                                    returnType = ATOM; // final closing bracket\n                                    state.sExprQuote = false; // turn off s-expr quote mode\n                                }\n                            }\n                        }\n                    } else {\n                        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else returnType = \"variable\";\n                    }\n            }\n            return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}