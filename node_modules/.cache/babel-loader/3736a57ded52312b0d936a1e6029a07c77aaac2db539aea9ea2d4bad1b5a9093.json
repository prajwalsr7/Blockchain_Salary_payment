{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haxe\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit;\n\n    // Tokenizer\n\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n    var A = kw(\"keyword a\"),\n      B = kw(\"keyword b\"),\n      C = kw(\"keyword c\");\n    var operator = kw(\"operator\"),\n      atom = {\n        type: \"atom\",\n        style: \"atom\"\n      },\n      attribute = {\n        type: \"attribute\",\n        style: \"attribute\"\n      };\n    var type = kw(\"typedef\");\n    var keywords = {\n      \"if\": A,\n      \"while\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"return\": C,\n      \"break\": C,\n      \"continue\": C,\n      \"new\": C,\n      \"throw\": C,\n      \"var\": kw(\"var\"),\n      \"inline\": attribute,\n      \"static\": attribute,\n      \"using\": kw(\"import\"),\n      \"public\": attribute,\n      \"private\": attribute,\n      \"cast\": kw(\"cast\"),\n      \"import\": kw(\"import\"),\n      \"macro\": kw(\"macro\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"untyped\": kw(\"untyped\"),\n      \"callback\": kw(\"cb\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"never\": kw(\"property_access\"),\n      \"trace\": kw(\"trace\"),\n      \"class\": type,\n      \"abstract\": type,\n      \"enum\": type,\n      \"interface\": type,\n      \"typedef\": type,\n      \"extends\": type,\n      \"implements\": type,\n      \"dynamic\": type,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|]/;\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    }\n    function toUnescaped(stream, end) {\n      var escaped = false,\n        next;\n      while ((next = stream.next()) != null) {\n        if (next == end && !escaped) return true;\n        escaped = !escaped && next == \"\\\\\";\n      }\n    }\n\n    // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n    var type, content;\n    function ret(tp, style, cont) {\n      type = tp;\n      content = cont;\n      return style;\n    }\n    function haxeTokenBase(stream, state) {\n      var ch = stream.next();\n      if (ch == '\"' || ch == \"'\") {\n        return chain(stream, state, haxeTokenString(ch));\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == \"0\" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return ret(\"number\", \"number\");\n      } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n        return ret(\"number\", \"number\");\n      } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n        toUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimsu]/);\n        return ret(\"regexp\", \"string-2\");\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, haxeTokenComment);\n        } else if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else {\n          stream.eatWhile(isOperatorChar);\n          return ret(\"operator\", null, stream.current());\n        }\n      } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n      } else if (ch == \"@\") {\n        stream.eat(/:/);\n        stream.eatWhile(/[\\w_]/);\n        return ret(\"metadata\", \"meta\");\n      } else if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      } else {\n        var word;\n        if (/[A-Z]/.test(ch)) {\n          stream.eatWhile(/[\\w_<>]/);\n          word = stream.current();\n          return ret(\"type\", \"variable-3\", word);\n        } else {\n          stream.eatWhile(/[\\w_]/);\n          var word = stream.current(),\n            known = keywords.propertyIsEnumerable(word) && keywords[word];\n          return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n        }\n      }\n    }\n    function haxeTokenString(quote) {\n      return function (stream, state) {\n        if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n        return ret(\"string\", \"string\");\n      };\n    }\n    function haxeTokenComment(stream, state) {\n      var maybeEnd = false,\n        ch;\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = haxeTokenBase;\n          break;\n        }\n        maybeEnd = ch == \"*\";\n      }\n      return ret(\"comment\", \"comment\");\n    }\n\n    // Parser\n\n    var atomicTypes = {\n      \"atom\": true,\n      \"number\": true,\n      \"variable\": true,\n      \"string\": true,\n      \"regexp\": true\n    };\n    function HaxeLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n    function inScope(state, varname) {\n      for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n    }\n    function parseHaxe(state, style, type, content, stream) {\n      var cc = state.cc;\n      // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n      cx.state = state;\n      cx.stream = stream;\n      cx.marked = null, cx.cc = cc;\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n      while (true) {\n        var combinator = cc.length ? cc.pop() : statement;\n        if (combinator(type, content)) {\n          while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n          if (cx.marked) return cx.marked;\n          if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n          if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n          return style;\n        }\n      }\n    }\n    function imported(state, typename) {\n      if (/[a-z]/.test(typename.charAt(0))) return false;\n      var len = state.importedtypes.length;\n      for (var i = 0; i < len; i++) if (state.importedtypes[i] == typename) return true;\n    }\n    function registerimport(importname) {\n      var state = cx.state;\n      for (var t = state.importedtypes; t; t = t.next) if (t.name == importname) return;\n      state.importedtypes = {\n        name: importname,\n        next: state.importedtypes\n      };\n    }\n    // Combinator utils\n\n    var cx = {\n      state: null,\n      column: null,\n      marked: null,\n      cc: null\n    };\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n    }\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n    function inList(name, list) {\n      for (var v = list; v; v = v.next) if (v.name == name) return true;\n      return false;\n    }\n    function register(varname) {\n      var state = cx.state;\n      if (state.context) {\n        cx.marked = \"def\";\n        if (inList(varname, state.localVars)) return;\n        state.localVars = {\n          name: varname,\n          next: state.localVars\n        };\n      } else if (state.globalVars) {\n        if (inList(varname, state.globalVars)) return;\n        state.globalVars = {\n          name: varname,\n          next: state.globalVars\n        };\n      }\n    }\n\n    // Combinators\n\n    var defaultVars = {\n      name: \"this\",\n      next: null\n    };\n    function pushcontext() {\n      if (!cx.state.context) cx.state.localVars = defaultVars;\n      cx.state.context = {\n        prev: cx.state.context,\n        vars: cx.state.localVars\n      };\n    }\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars;\n      cx.state.context = cx.state.context.prev;\n    }\n    popcontext.lex = true;\n    function pushlex(type, info) {\n      var result = function () {\n        var state = cx.state;\n        state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n      };\n      result.lex = true;\n      return result;\n    }\n    function poplex() {\n      var state = cx.state;\n      if (state.lexical.prev) {\n        if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n    poplex.lex = true;\n    function expect(wanted) {\n      function f(type) {\n        if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n      }\n      return f;\n    }\n    function statement(type) {\n      if (type == \"@\") return cont(metadef);\n      if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n      if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n      if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n      if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n      if (type == \";\") return cont();\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n      if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n      if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n      if (type == \"case\") return cont(expression, expect(\":\"));\n      if (type == \"default\") return cont(expect(\":\"));\n      if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n      if (type == \"import\") return cont(importdef, expect(\";\"));\n      if (type == \"typedef\") return cont(typedef);\n      return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n    }\n    function expression(type) {\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n      if (type == \"type\") return cont(maybeoperator);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"keyword c\") return cont(maybeexpression);\n      if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n      if (type == \"operator\") return cont(expression);\n      if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n      return cont();\n    }\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n    function maybeoperator(type, value) {\n      if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n      if (type == \"operator\" || type == \":\") return cont(expression);\n      if (type == \";\") return;\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n      if (type == \".\") return cont(property, maybeoperator);\n      if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n    }\n    function maybeattribute(type) {\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"var\") return cont(vardef1);\n    }\n    function metadef(type) {\n      if (type == \":\") return cont(metadef);\n      if (type == \"variable\") return cont(metadef);\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n    }\n    function metaargs(type) {\n      if (type == \"variable\") return cont();\n    }\n    function importdef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n    }\n    function typedef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n        return cont();\n      }\n    }\n    function maybelabel(type) {\n      if (type == \":\") return cont(poplex, statement);\n      return pass(maybeoperator, expect(\";\"), poplex);\n    }\n    function property(type) {\n      if (type == \"variable\") {\n        cx.marked = \"property\";\n        return cont();\n      }\n    }\n    function objprop(type) {\n      if (type == \"variable\") cx.marked = \"property\";\n      if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n    }\n    function commasep(what, end) {\n      function proceed(type) {\n        if (type == \",\") return cont(what, proceed);\n        if (type == end) return cont();\n        return cont(expect(end));\n      }\n      return function (type) {\n        if (type == end) return cont();else return pass(what, proceed);\n      };\n    }\n    function block(type) {\n      if (type == \"}\") return cont();\n      return pass(statement, block);\n    }\n    function vardef1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse, vardef2);\n      }\n      return cont();\n    }\n    function vardef2(type, value) {\n      if (value == \"=\") return cont(expression, vardef2);\n      if (type == \",\") return cont(vardef1);\n    }\n    function forspec1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(forin, expression);\n      } else {\n        return pass();\n      }\n    }\n    function forin(_type, value) {\n      if (value == \"in\") return cont();\n    }\n    function functiondef(type, value) {\n      //function names starting with upper-case letters are recognised as types, so cludging them together here.\n      if (type == \"variable\" || type == \"type\") {\n        register(value);\n        return cont(functiondef);\n      }\n      if (value == \"new\") return cont(functiondef);\n      if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n    }\n    function typeuse(type) {\n      if (type == \":\") return cont(typestring);\n    }\n    function typestring(type) {\n      if (type == \"type\") return cont();\n      if (type == \"variable\") return cont();\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n    }\n    function typeprop(type) {\n      if (type == \"variable\") return cont(typeuse);\n    }\n    function funarg(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse);\n      }\n    }\n\n    // Interface\n    return {\n      startState: function (basecolumn) {\n        var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n        var state = {\n          tokenize: haxeTokenBase,\n          reAllowed: true,\n          kwAllowed: true,\n          cc: [],\n          lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n          localVars: parserConfig.localVars,\n          importedtypes: defaulttypes,\n          context: parserConfig.localVars && {\n            vars: parserConfig.localVars\n          },\n          indented: 0\n        };\n        if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\") state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n      token: function (stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n          state.indented = stream.indentation();\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == \"comment\") return style;\n        state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n        state.kwAllowed = type != '.';\n        return parseHaxe(state, style, type, content, stream);\n      },\n      indent: function (state, textAfter) {\n        if (state.tokenize != haxeTokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n          lexical = state.lexical;\n        if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n        var type = lexical.type,\n          closing = firstChar == type;\n        if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n  CodeMirror.defineMode(\"hxml\", function () {\n    return {\n      startState: function () {\n        return {\n          define: false,\n          inString: false\n        };\n      },\n      token: function (stream, state) {\n        var ch = stream.peek();\n        var sol = stream.sol();\n\n        ///* comments */\n        if (ch == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n        if (sol && ch == \"-\") {\n          var style = \"variable-2\";\n          stream.eat(/-/);\n          if (stream.peek() == \"-\") {\n            stream.eat(/-/);\n            style = \"keyword a\";\n          }\n          if (stream.peek() == \"D\") {\n            stream.eat(/[D]/);\n            style = \"keyword c\";\n            state.define = true;\n          }\n          stream.eatWhile(/[A-Z]/i);\n          return style;\n        }\n        var ch = stream.peek();\n        if (state.inString == false && ch == \"'\") {\n          state.inString = true;\n          stream.next();\n        }\n        if (state.inString == true) {\n          if (stream.skipTo(\"'\")) {} else {\n            stream.skipToEnd();\n          }\n          if (stream.peek() == \"'\") {\n            stream.next();\n            state.inString = false;\n          }\n          return \"string\";\n        }\n        stream.next();\n        return null;\n      },\n      lineComment: \"#\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConfig","indentUnit","kw","type","style","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","escaped","next","content","ret","tp","cont","haxeTokenBase","ch","haxeTokenString","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","quote","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","parseHaxe","cc","cx","marked","lexical","hasOwnProperty","combinator","length","pop","statement","lex","imported","typename","charAt","len","importedtypes","i","registerimport","importname","t","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","basecolumn","defaulttypes","token","sol","indentation","eatSpace","indent","textAfter","firstChar","closing","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","inString","peek","skipTo"],"sources":["C:/Users/User/Downloads/Salary Payments/node_modules/codemirror/mode/haxe/haxe.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haxe\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n\n  // Tokenizer\n\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n  var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\n  var type = kw(\"typedef\");\n  var keywords = {\n    \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n    \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n    \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n    \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n    \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n    \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n    \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n    \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n    \"true\": atom, \"false\": atom, \"null\": atom\n  };\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function toUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return true;\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function haxeTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      return chain(stream, state, haxeTokenString(ch));\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n      toUnescaped(stream, \"/\");\n      stream.eatWhile(/[gimsu]/);\n      return ret(\"regexp\", \"string-2\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, haxeTokenComment);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n    } else if (ch == \"@\") {\n      stream.eat(/:/);\n      stream.eatWhile(/[\\w_]/);\n      return ret (\"metadata\", \"meta\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    } else {\n      var word;\n      if(/[A-Z]/.test(ch)) {\n        stream.eatWhile(/[\\w_<>]/);\n        word = stream.current();\n        return ret(\"type\", \"variable-3\", word);\n      } else {\n        stream.eatWhile(/[\\w_]/);\n        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n        return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                       ret(\"variable\", \"variable\", word);\n      }\n    }\n  }\n\n  function haxeTokenString(quote) {\n    return function(stream, state) {\n      if (toUnescaped(stream, quote))\n        state.tokenize = haxeTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function haxeTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = haxeTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function HaxeLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseHaxe(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n        return style;\n      }\n    }\n  }\n\n  function imported(state, typename) {\n    if (/[a-z]/.test(typename.charAt(0)))\n      return false;\n    var len = state.importedtypes.length;\n    for (var i = 0; i<len; i++)\n      if(state.importedtypes[i]==typename) return true;\n  }\n\n  function registerimport(importname) {\n    var state = cx.state;\n    for (var t = state.importedtypes; t; t = t.next)\n      if(t.name == importname) return;\n    state.importedtypes = { name: importname, next: state.importedtypes };\n  }\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next)\n      if (v.name == name) return true;\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(varname, state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else if (state.globalVars) {\n      if (inList(varname, state.globalVars)) return;\n      state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: null};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  popcontext.lex = true;\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function f(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(f);\n    }\n    return f;\n  }\n\n  function statement(type) {\n    if (type == \"@\") return cont(metadef);\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                   poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"import\") return cont(importdef, expect(\";\"));\n    if (type == \"typedef\") return cont(typedef);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"type\" ) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" || type == \":\") return cont(expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n\n  function maybeattribute(type) {\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"var\") return cont(vardef1);\n  }\n\n  function metadef(type) {\n    if(type == \":\") return cont(metadef);\n    if(type == \"variable\") return cont(metadef);\n    if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n  }\n  function metaargs(type) {\n    if(type == \"variable\") return cont();\n  }\n\n  function importdef (type, value) {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n  }\n\n  function typedef (type, value)\n  {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n  }\n\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(forin, expression)\n    } else {\n      return pass()\n    }\n  }\n  function forin(_type, value) {\n    if (value == \"in\") return cont();\n  }\n  function functiondef(type, value) {\n    //function names starting with upper-case letters are recognised as types, so cludging them together here.\n    if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n    if (value == \"new\") return cont(functiondef);\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n  }\n  function typeuse(type) {\n    if(type == \":\") return cont(typestring);\n  }\n  function typestring(type) {\n    if(type == \"type\") return cont();\n    if(type == \"variable\") return cont();\n    if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n  }\n  function typeprop(type) {\n    if(type == \"variable\") return cont(typeuse);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont(typeuse);}\n  }\n\n  // Interface\n  return {\n    startState: function(basecolumn) {\n      var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n      var state = {\n        tokenize: haxeTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        importedtypes: defaulttypes,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != '.';\n      return parseHaxe(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != haxeTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n\nCodeMirror.defineMode(\"hxml\", function () {\n\n  return {\n    startState: function () {\n      return {\n        define: false,\n        inString: false\n      };\n    },\n    token: function (stream, state) {\n      var ch = stream.peek();\n      var sol = stream.sol();\n\n      ///* comments */\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (sol && ch == \"-\") {\n        var style = \"variable-2\";\n\n        stream.eat(/-/);\n\n        if (stream.peek() == \"-\") {\n          stream.eat(/-/);\n          style = \"keyword a\";\n        }\n\n        if (stream.peek() == \"D\") {\n          stream.eat(/[D]/);\n          style = \"keyword c\";\n          state.define = true;\n        }\n\n        stream.eatWhile(/[A-Z]/i);\n        return style;\n      }\n\n      var ch = stream.peek();\n\n      if (state.inString == false && ch == \"'\") {\n        state.inString = true;\n        stream.next();\n      }\n\n      if (state.inString == true) {\n        if (stream.skipTo(\"'\")) {\n\n        } else {\n          stream.skipToEnd();\n        }\n\n        if (stream.peek() == \"'\") {\n          stream.next();\n          state.inString = false;\n        }\n\n        return \"string\";\n      }\n\n      stream.next();\n      return null;\n    },\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}