{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function (config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\", \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\", \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\", \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\"def\", \"fun\", \"macro\", \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\", \"do\", \"for\"];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\n    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\n    var dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent,\n      \"fun\": tokenFollowIdent,\n      \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType,\n      \"module\": tokenFollowType,\n      \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType,\n      \"enum\": tokenFollowType,\n      \"union\": tokenFollowType\n    };\n    var matching = {\n      \"[\": \"]\",\n      \"{\": \"}\",\n      \"(\": \")\",\n      \"<\": \">\"\n    };\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      // Macros\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      }\n\n      // Comments\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Variables and keywords\n      var matched;\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n        matched = stream.current();\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n            state.blocks.push(matched);\n            state.currentIndent += 1;\n          } else if (matched == \"end\") {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n        return \"variable\";\n      }\n\n      // Class variables and instance variables\n      // or attributes\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      }\n\n      // Constants and types\n      if (stream.match(types)) {\n        return \"tag\";\n      }\n\n      // Symbols or ':' operator\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) || stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n        stream.eat(\":\");\n        return \"operator\";\n      }\n\n      // Strings\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      }\n\n      // Strings or regexps or macro variables or '%' operator\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if (delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else if (stream.eat('%')) {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      }\n\n      // Here Docs\n      if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state);\n      }\n\n      // Characters\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      }\n\n      // Numbers\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F_]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7_]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01_]+/);\n        }\n        return \"number\";\n      }\n      if (stream.eat(/^\\d/)) {\n        stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      }\n\n      // Operators\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n        return \"operator\";\n      }\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      }\n\n      // Parens and braces\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      }\n\n      // Escapes\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n      stream.next();\n      return null;\n    }\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n        var nextStyle = tokenBase(stream, state);\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n        return nextStyle;\n      };\n    }\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n        return tokenBase(stream, state);\n      };\n    }\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n      var matched;\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n        stream.eat(/[?!]/);\n      }\n      state.tokenize.pop();\n      return \"def\";\n    }\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n      state.tokenize.pop();\n      return \"def\";\n    }\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n            var ch = stream.next();\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n            escaped = embed && ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n        return style;\n      };\n    }\n    function tokenHereDoc(phrase, embed) {\n      return function (stream, state) {\n        if (stream.sol()) {\n          stream.eatSpace();\n          if (stream.match(phrase)) {\n            state.tokenize.pop();\n            return \"string\";\n          }\n        }\n        var escaped = false;\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return \"string\";\n            }\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return \"string\";\n            }\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return \"string\";\n            }\n            escaped = embed && stream.next() == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n        return \"string\";\n      };\n    }\n    return {\n      startState: function () {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          lastStyle: null,\n          blocks: []\n        };\n      },\n      token: function (stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n          state.lastStyle = style;\n        }\n        return style;\n      },\n      indent: function (state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n        return config.indentUnit * state.currentIndent;\n      },\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywordsArray","indentKeywords","indentExpressionKeywordsArray","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","tokenMacroDef","tokenFollowType","matching","tokenBase","eatSpace","lastToken","match","tokenMacro","peek","skipToEnd","matched","eat","current","test","blocks","indexOf","currentIndent","lastStyle","pop","hasOwnProperty","tokenNest","tokenQuote","style","embed","delim","next","tokenHereDoc","begin","started","length","nextStyle","escaped","ch","phrase","sol","startState","token","indent","textAfter","replace","indentUnit","fold","electricInput","concat","lineComment","defineMIME"],"sources":["C:/Users/User/Downloads/Multisender-App-main/node_modules/codemirror/mode/crystal/crystal.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function(config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\n      \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n      \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n      \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n      \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n      \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n      \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n    ]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\n      \"def\", \"fun\", \"macro\",\n      \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n      \"do\", \"for\"\n    ];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\n    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\n    var dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n    };\n    var matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      // Macros\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      }\n\n      // Comments\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Variables and keywords\n      var matched;\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n\n        matched = stream.current();\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n            state.blocks.push(matched);\n            state.currentIndent += 1;\n          } else if (matched == \"end\") {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n\n        return \"variable\";\n      }\n\n      // Class variables and instance variables\n      // or attributes\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      }\n\n      // Constants and types\n      if (stream.match(types)) {\n        return \"tag\";\n      }\n\n      // Symbols or ':' operator\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) ||\n                   stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n        stream.eat(\":\");\n        return \"operator\";\n      }\n\n      // Strings\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      }\n\n      // Strings or regexps or macro variables or '%' operator\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if(delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else if (stream.eat('%')) {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      }\n\n      // Here Docs\n      if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n      }\n\n      // Characters\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      }\n\n      // Numbers\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F_]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7_]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01_]+/);\n        }\n        return \"number\";\n      }\n\n      if (stream.eat(/^\\d/)) {\n        stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      }\n\n      // Operators\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n        return \"operator\";\n      }\n\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      }\n\n      // Parens and braces\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      }\n\n      // Escapes\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n\n        var nextStyle = tokenBase(stream, state);\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n\n        return nextStyle;\n      };\n    }\n\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n\n        return tokenBase(stream, state);\n      };\n    }\n\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var matched;\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n        stream.eat(/[?!]/);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n\n            var ch = stream.next();\n\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n\n            escaped = embed && ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    function tokenHereDoc(phrase, embed) {\n      return function (stream, state) {\n        if (stream.sol()) {\n          stream.eatSpace()\n          if (stream.match(phrase)) {\n            state.tokenize.pop();\n            return \"string\";\n          }\n        }\n\n        var escaped = false;\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return \"string\";\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return \"string\";\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return \"string\";\n            }\n\n            escaped = embed && stream.next() == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return \"string\";\n      }\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          lastStyle: null,\n          blocks: []\n        };\n      },\n\n      token: function (stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n          state.lastStyle = style;\n        }\n\n        return style;\n      },\n\n      indent: function (state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n\n        return config.indentUnit * state.currentIndent;\n      },\n\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}